<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="it">
  <head>
    <!-- <script type="text/javascript" src="../css/issStyle.js"></script> -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"
      crossorigin="anonymous"
    ></script>
    <!-- <link rel="stylesheet" type="text/css" href="../../resources/_styles/style.css" /> -->
    <link rel="stylesheet" type="text/css" href="./css/style.css" />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <title>ISS25 - Sprint 1</title>
  </head>

  <body>
    <div id="top">
      <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE - Sprint 1</h1>
    </div>
    <div class="body">
      <h2>Introduction</h2>
      <div class="remark">
        <div class="textbody grid-x grid-margin-x align-middle">
          <div class="medium-8">
            Nello
            <a href="../../Sprint0/userDocs/sprint0_v3.html">Sprint 0</a> è
            stato realizzato un primo modello del sistema ottenuto tramite la
            formalizzazione dei requisiti forniti dal committente (figura a
            destra). <br />
            <br />
            L'obiettivo dello Sprint 1 è di analizzare le problematiche del core
            business emerse nella fase di analisi dei requisiti e realizzarne
            un'implementazione funzionante da fornire al committente.
          </div>
          <div class="medium-4">
            <img
              src="../../Sprint0/sprint0_system_overviewarch.png"
              alt="Sprint 0 architecture"
              width="75%"
            />
          </div>
        </div>
      </div>

      <h2>Requirements</h2>

      <div class="remark">
        <!-- FORSE FARE COPIA E INCOLLA HA SENSO -->
        I requisiti che si vuole soddisfare in questo sprint sono i
        seguenti:
        <ul>
<li> the software system is able to receive the request to load on the cargo a product container already registered in the productservice.

The request is rejected when:

the product-weight is evaluated too high, since the ship can carry a maximum load of MaxLoad>0  kg.
the hold is already full, i.e. the 4 slots are alrready occupied.
If the request is accepted, the cargoservice associates a slot to the product PID and returns the name of the reserved slot. Afttwerds, it waits that the product container is delivered to the ioport. In the meantime, other requests are not elaborated. </li>
<li>
  is able to ensure that the product container is placed by the cargorobot within its reserved slot. At the end of the work:

the cargorobot should returns to its HOME location.
the cargoservice can process another load-request
</li>
<li>
  interrupts any activity and turns on a led if the sonar sensor measures a distance D > DFREE for at least 3 secs (perhaps a sonar failure). The service continues its activities as soon as the sonar measures a distance D <= DFREE.
</li>
        </ul>
      </div>

      <h2>Problem analysis</h2>

      <div class="remark">
        <div class="textparagraph">
          <h3>Come si rappresenta la hold?</h3>
          <div class="textbody">
            Come analizzato durante il precedente sprint, il DDR
            rappresenta internamente la hold come un piano cartesiano.
            Questa viene quindi suddivisa in una griglia dove ciascuna cella è
            un quadrato avente lato pari alla dimensione del basicrobot, così da
            poter formalizzare il concetto di posizione, intesa come una coppia
            di coordinate cartesiane. La home si troverà nel punto di origine,
            quindi alle coordinate (0,0) mentre i vari slot sono visibili
            nell'immagine seguente, che è analoga alla configurazione già
            presente all'interno del robot fornito dal committente e per questo
            non è modificabile.
            <br />
            <div class="text-center">
              <img src="resources/map.png" alt="grid" width="25%" />
            </div>
            In particolare si avranno:
            <ul>
              <li>Home alle coordinate (0,0)</li>
              <li>Slot 1 alle coordinate (2,1)</li>
              <li>Slot 2 alle coordinate (3,1)</li>
              <li>Slot 3 alle coordinate (2,3)</li>
              <li>Slot 4 alle coordinate (3,3)</li>
              <li>Slot 5 alle coordinate (4,2)</li>
              <li>
                Non essendo specificata nella documentazione fornita
                dal committente, suggeriamo di posizionare la IOPort
                alle coordinate (1,5)
              </li>
            </ul>
          </div>
        </div>

        <div class="textparagraph">
          <h3>Come muovere il basicrobot?</h3>
          <div class="textbody">
            Al componente <strong>cargorobot</strong> spetta il compito di
            comunicare con basicrobot attraverso messaggi, come analizzato
            nello sprint precedente. Questo approccio favorisce la separazione
            delle funzionalità dei vari componenti facendo in modo che il
            cargoservice mantenga solo la funzionalità di gestore delle
            comunicazioni.
            <br />
            <h4>Gestione del movimento</h4>
            Il basicrobot mette a disposizione diversi messaggi per muovere il
            DDR. Sono stati identificati due messaggi principali che
              permettono di definire un piano di esecuzione per spostare il
              robot da un punto A ad un punto B.
              <table class="robot-table">
                <thead>
                  <tr>
                    <th>Messaggio</th>
                    <th>Funzionamento</th>
                    <th>Componenti</th>
                    <th>Note</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>moverobot(TARGETX, TARGETY)</td>
                    <td>
                      Gestisce le richieste di posizionamento, determina il
                      piano di movimento, restituisce moverobotdone, se ok,
                      moverobotfailed, se errore.
                    </td>
                    <td>planexec, robotpos</td>
                    <td>
                      Gestisce anche il comando di utilità setpos(X,Y,D) per
                      allienare la rappresentazione del planner sulla posizione
                      corrente reale del robot fissata manualmente.
                    </td>
                  </tr>
                  <tr>
                    <td>doplan(PATH, STEPTIME)</td>
                    <td>
                      Gestisce richieste di esecuzione di una serie di mosse,
                      restituisce doplandone, se ok, doplanfailed, se errore.
                    </td>
                    <td>planexec</td>
                    <td>Non usa e non aggiorna alcuna mappa della stanza</td>
                  </tr>
                </tbody>
              </table>
              Per semplificare lo sviluppo delegando le operazioni di scelta del
              percorso da eseguire al basicrobot, il quale è munito di un
              sistema automatico di pianificazione del percorso affidato al componente <strong>planner</strong>,
              si consiglia l'utilizzo del messaggio <i>moverobot(TARGETX, TARGETY)</i>.
              Così facendo il cargorobot dovrà essere in grado di tradurre l'identificatore dello slot ricevuto nelle rispettive coordinate assolute.
            </div>
            <br />
            <div class="textbody">
              <h4>Come recuperare le coordinate?</h4>
              risulta fondamentale la possibilità di recuperare le coordinate
              dei punti di interesse all'interno della hold, sono stati
              identificati due possibili approcci:
              <ul>
                <li>
                  Memorizzazione delle coordinate all'interno del codice
                  sorgente
                </li>
                <li>
                  Memorizzazione delle coordinate in una base di conoscenza
                  prolog
                </li>
              </ul>

              A questo fine si ritiene opportuno sfruttare il secondo
              approccio in quanto più flessibile e scalabile in caso di
              modifiche future alla mappa.
            </div>
          </div>
        
        <div class="textparagraph">
          <h3>Come sfruttare il productservice e gestire la hold?</h3>
          <div class="textbody">
            Lo stato della hold (slot liberi e peso della nave cargo) deve
            essere gestito da uno degli attori del sistema; per fare in modo che
            il cargoservice mantenga solo la funzionalità di gestore delle
            comunicazioni si ritiene opportuno affidare questa responsabilità ad
            un attore dedicato di nome <strong> holdmanager </strong>, il quale
            si occuperà anche dell'interfacciamento con il
            <strong> productservice </strong>. Il productservice viene fornito
            dal committente e permette di recuperare le informazioni riguardanti
            un prodotto tramite l'invio di un messaggio
            <strong> getProduct </strong> nel quale viene specificato il PID del
            prodotto da ricercare.
            <br />

            Questo attore <strong> holdmanager </strong> fungerà da
            intermediario tra il cargoservice e il productservice, prendendo in
            carico la gestione della hold tramite il tracciamento degli slot
            liberi, di quelli occupati e del peso dei prodotti caricati nella
            nave cargo.
            <br />
            <div class="textbody">
              <h4>Tracciamento del carico</h4>
              Il tracciamento del carico potrà avvenire in due modi:
              <ul>
                <li>Tracciamento persistente</li>
                <li>Tracciamento non persistente</li>
              </ul>

              Per avere una visione dello stato della hold anche in caso di
              crash del sistema si ritiene opportuno seguire il primo approccio.
            </div>

          
            
        </div>

        
        </div>
        
        <div class="textparagraph">
          <h3> Come simulare i componenti non appartenenti al core business? </h3>
          <div class="textbody">
            Essendo lo Sprint1 incentrato sullo sviluppo del core business, i componenti non appartenenti a questa parte del sistema possono essere simulati nelle loro interazioni con il cargoservice tramite entità fittizie.
          </div>
        </div>
        
        </div>
        <h2>Logical Architecture</h2>

      <div class="medium-12 text-center remark">
        <img
          src="./resources/sprint1_LogicalModel.png"
          class="text-center"
          alt="map"
          width="100%"
        />

      </div>
      </div>
    </div>

    <h2>Test plans</h2>
    <div class="remark">
      <div class="textbody">
        Lo scopo della fase di test è quello di verificare il funzionamento del
        core business, cioè dei componenti
        <strong> cargoservice </strong>, <strong> productservice</strong> e
        <strong> cargorobot </strong>.

        <div class="textbody">
          <table class="test-plan-table">
            <thead>
              <tr>
                <th>Test</th>
                <th>Attori</th>
                <th>Servizi</th>
                <th>Descrizione</th>
                <th>Modello</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Evento di richiesta caricamento</td>
                <td>mockuser; cargoservice;</td>
                <td></td>
                <td>
                  Il QActor tester, simulando il mockuser, invia una richiesta
                  di caricamento contenente il PID del prodotto al cargoservice
                </td>
                <td>test_interactions.qak<br />CargoSystemTest.java</td>
              </tr>
              <tr>
                <td>Verifica prodotto registrato e peso</td>
                <td>cargoservice; holdManager;</td>
                <td>productService;</td>
                <td>
                  Il cargoservice invia il PID ricevuto a holdManager che
                  controlla, interrogando il productService, che il prodotto sia
                  registrato e che il peso non superi il limite imposto dai
                  vincoli. Invia un messaggio contenente lo slot in cui mettere
                  il prodotto o un messaggio di errore a cargoservice.
                </td>
                <td>test_interactions.qak<br />CargoSystemTest.java</td>
              </tr>
              <tr>
                <td>Arrivo di un carico</td>
                <td>mockuser; cargoservice; cargoRobot</td>
                <td></td>
                <td>
                  Il QActor tester, simulando il mockuser, invia un messaggio a
                  cargoservice quando rileva la presenza di un pacco contenente
                  lo slot in cui depositare il pacco.
                </td>
                <td>test_interactions.qak<br />CargoSystemTest.java</td>
              </tr>
              <tr>
                <td>Avvio del cargoRobot</td>
                <td>cargoservice; cargoRobot;</td>
                <td>basicRobot</td>
                <td>
                  Il cargoservice invia al cargoRobot un messaggio contenente lo
                  slot a cui andare/ le coordinate dello slot a cui andare.
                  Quest'ultimo pilota il basicRobot.
                </td>
                <td>test_interactions.qak<br />CargoSystemTest.java</td>
              </tr>
              <tr>
                <td>Fine caricamento</td>
                <td>cargoRobot; cargoservice</td>
                <td>basicRobot</td>
                <td>
                  Il cargoRobot pilota il basicRobot fino alla HOME, manda un
                  segnale a cargoservice che si rimette in ascolto di nuove
                  richieste di carico.
                </td>
                <td><br /></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <h2>Project</h2>
    <div class="remark">
      Per seguire il single responsibility principle è stato deciso di affidare
      a diversi attori la gestione delle distinte parti del sistema.

      <div class="textparagraph">
        <h3>comportamento del cargoservice</h3>
        <div class="textbody">
          Il cargoservice è l'attore che ha il compito di controllare il
          funzionamento del sistema e coordinare le comunicazioni tra i diversi
          componenti. 
          <br>
          <br>
          Al momento della ricezione di una richiesta di caricamento
          da parte dell'utente, contenente il PID del prodotto che intende
          depositare, verrà inviata all'<strong>holdmanager</strong> una
          richiesta <i>controlproduct(pid)</i>, rimanendo dunque in attesa di
          una risposta corrispondente all'esito, <i>productaccepted(slot)</i> o
          <i>productrejected()</i> conseguenti ai controlli di cui è
          responsabile <strong>holdmanager</strong>.
          
          <pre style="width: 80%; padding: 1px; border: 5px solid #ccc; border-radius: 5px; overflow: auto;"><code>State checkLoadRequest { //asking holdmanager for pid
  onMsg ( loadrequest : loadrequest(PID) ){
    [# 
      PID = payloadArg(0).toInt();
    #]
    println("$name : Asking for pid: $PID") color green 
    request holdmanager -m controlproduct : controlproduct($PID)
  }
}
Transition t
whenReply productaccepted -> productAccepted
whenReply productrejected -> productRejected
</code></pre><br/>
          Al momento della ricezione
          della risposta comunicherà all'utente l'esito e, se sarà positivo,
          inizialmente scatenerà un evento (utile per l'interazione con i
          componenti non ancora definiti in questa fase) e successivamente
          rimarrà in attesa del segnale di carico proveniente dal sonar. In caso
          contrario tornerà nello stato di attesa delle richieste di carico.

          Al momento della ricezione del segnale da parte del sonar che indica la presenza del
          prodotto, comunicherà al
          <strong>cargorobot</strong> tramite richiesta <i>load(slot)</i> lo
          slot precedentemente indicato dall'<strong>holdmanager</strong> in cui
          andare a depositare il prodotto.
           
<pre><code>// Attende segnale di deposito dal sonar
State waitForDeposit {
  println ("$name : waiting for sonar deposit signal") color green
  emit waitingForDeposit : waitingForDeposit
}
Transition t
  whenEvent doDeposit -> doDeposit
  whenInterruptEvent sonaralert -> handleAlert

// Ricevuta richiesta di deposito
State doDeposit{
  println ("$name : package detected, proceeding with the loading") color green
  request cargorobot -m load : load($SLOT_TO_LOAD)
  emit stopWaitingForDeposit : stopWaitingForDeposit
} 
Transition t
  whenEvent productloaded -> loadEnded
  whenInterruptEvent sonaralert -> handleAlert
  
// Caricamento terminato, reset parametri
State loadEnded {
  println ("$name : loading process ended") color green
  [#  		
    PID = 0;
    SLOT_TO_LOAD = -1;
  #]
} 
Goto wait</code></pre><br/>
          Successivamente attenderà il
          completamento delle operazioni del <strong>cargorobot</strong>, il
          quale risponderà con <i>loadended()</i> quando avrà terminato la procedura
          di caricamento, prima di tornare in attesa di
          una nuova richiesta di carico. 

          <pre><code>State wait{
  println ("$name : waiting for requests...")	color green	
}
Transition t
	whenRequest loadrequest -> checkLoadRequest
	whenInterruptEvent sonaralert -> handleAlert
</code></pre><br/>

  Oltre al suo normale flusso di esecuzione, il cargoservice dovrà
  gestire i segnali di interruzione provenienti dal sonar in caso di
  malfunzionamento, così da andare a sospendere le attività di tutti i
  componenti del sistema fino al rientro dell'errore

<pre><code>whenInterruptEvent sonaralert -> handleAlert //dichiarato in ogni stato dell'attore

State handleAlert{
  println ("$name : sonar in alert state") color red
  emit stopthesystem : stopthesystem(0)
}
Transition t
  whenEvent sonarok -> resumeOperations</code></pre>
        </div>
      </div>

      <div class="textparagraph">
        <h3>comportamento del cargorobot</h3>
        <div class="textbody">
          Al momento della ricezione della richiesta <i>load(slot)</i> da parte
          del cargoservice, il cargorobot si occuperà di inviare le istruzioni
          di spostamento al basicrobot. In particolare vengono identificate 3
          fasi di movimento principali, le quali verranno eseguite in sequenza:
          <ul>
            <li>Spostamento dalla posizione corrente alla ioport</li>
            <li>Spostamento dalla ioport allo slot specificato</li>
            <li>Spostamento dallo slot alla home</li>
          </ul>

<pre><code>State movetoioport {
  delay 2000
  onMsg (load : load(SLOT)) {
    
    [#
      TARGETSLOT = payloadArg(0).toInt()
      val DEST = Pos.ioport.name
    #]
    solve (getPoint($DEST,TX,TY,TDIR))
    [#
      val X = getCurSol("TX").toString();
      val Y = getCurSol("TY").toString();
      val D = getCurSol("TDIR").toString();  
      destination=DEST
      moving = true  
    #]
    println("$name : moving robot to slot IOPORT at Positions ($X,$Y)") color yellow
    request basicrobot -m moverobot:moverobot($X,$Y)
  }
}
Transition t 
  whenReply moverobotdone -> movetoslot
  whenReply moverobotfailed -> movefailed
  whenInterruptEvent stopthesystem -> systemStopped
	
State movetoslot {
  delay 2000
  onMsg ( moverobotdone : moverobotdone(ARG)) {
    [#
      val slot = "slot$TARGETSLOT"      
      val DEST = Pos.valueOf(slot).name
    #]
    solve (getPoint($DEST,TX,TY,TDIR))
    [#
      val X = getCurSol("TX").toString();
      val Y = getCurSol("TY").toString();
      val D = getCurSol("TDIR").toString();
      moving = true
      destination = TARGETSLOT.toString()
    #]
    
    println("$name : moving robot to slot $TARGETSLOT at Positions ($X,$Y)") color yellow
    request basicrobot -m moverobot:moverobot($X,$Y)
		}
	}
	Transition t
		whenReply moverobotdone -> movetohome
		whenReply moverobotfailed -> movefailed
		whenInterruptEvent stopthesystem -> systemStopped
	
State movetohome {
  delay 2000
  onMsg ( moverobotdone : moverobotdone(ARG)) {
    [#val DEST = Pos.home.name#]
    solve (getPoint($DEST,TX,TY,TDIR))
      [#

      val X = getCurSol("TX").toString();
      val Y = getCurSol("TY").toString();
      val D = getCurSol("TDIR").toString();
      
      
      
      moving = true
      destination = DEST
    
    #]
    
    println("$name : moving robot to slot HOME at Position ($X,$Y)") color yellow
    request basicrobot -m moverobot:moverobot($X,$Y)
  }
}
Transition t
  whenReply moverobotdone -> ended
  whenReply moverobotfailed -> movefailed
  whenInterruptEvent stopthesystem -> systemStopped</code></pre><br/>

          Le coordinate delle diverse destinazioni verranno recuperate da una
          base di conoscenza prolog. Nella base di conoscenza sono definiti dei
          predicati del tipo:
          <i>position(X, Y, DIR, P).</i>
          che associano a ciascun punto della mappa (come slot, home, ioport) le
          coordinate assolute (X, Y) e la direzione DIR. Il predicato di
          accesso:
          <i>getPoint(P, X, Y, DIR) :- position(X, Y, DIR, P).</i>
          consente al cargorobot di ottenere le coordinate e la direzione
          relative a una determinata posizione P.
          <ul>
            <li>x: ascissa del punto</li>
            <li>y: ordinata del punto</li>
            <li>
              direzione: permetterà di ruotare il robot verso la posizione
              rilevante di interesse
            </li>
          </ul>
        </div>
      </div>

      <div class="textparagraph">
        <h3>comportamento di holdmanager</h3>
        <div class="textbody">
          Al momento della ricezione della richiesta
          <i>controlproduct(pid)</i> da parte del cargoservice, holdmanager si
          occuperà di gestire il controllo del prodotto relazionandosi
          direttamente con <strong>productservice</strong>. Al momento della
          ricezione di una richiesta <i>controlproduct(pid)</i> proveniente dal
          cargoservice invierà una richiesta <i>getProduct(pid)</i> a
          <strong>productservice</strong> per recuperare le informazioni
          riguardanti il prodotto specificato.
          
<pre><code>State handleControlRequest {
	onMsg( controlproduct : controlproduct(PID) ) {
    [# val PID = payloadArg(0).toInt() #]
    println("$name : received control request for PID : $PID") color blue 
    request productservice -m getProduct : product($PID)
	}
}
Transition t
  whenReply getProductAnswer -> checkProductAnswer
</code></pre><br/>
          
          In base al payload della risposta
          <i>getProductAnswer(JSonString)</i> holdmanager otterrà i dati del
          prodotto in formato JSON e se il PID risulterà essere maggiore di 0
          (prodotto registrato) verificherà se il peso del prodotto è adeguato
          alla capacità massima della stiva e deciderà a che slot assegnare il
          carico (se sono presenti slot liberi). Infine, in caso i controlli
          abbiano avuto esito positivo, invierà una risposta al cargoservice con
          il messaggio <i>productaccepted(slot)</i> specificando lo slot scelto,
          in caso contrario verrà inviata una risposta di rifiuto
          <i>productrejected()</i>. 

<pre><code>State checkProductAnswer {
  onMsg ( getProductAnswer : product(JsonString) ) {
    [# 				
      val parser = JSONParser()
      val jsonString = payloadArg(0).toString()
      val jsonObj = parser.parse(jsonString) as JSONObject
      
      val pid = (jsonObj["productId"] as Long).toInt()
      val weight = (jsonObj["weight"] as Long).toInt()

      var rejected = false
      var ERMSG = ""	
      var SLOT = 0		
      
      if( pid > 0 ) {					// Prodotto registrato
        if ( MAXLOAD >= (weights.sumOf {it} + weight)) {	// Capienza stiva sufficiente
          SLOT = pids.indexOfFirst { it == 0 }
          if(SLOT < 0) {	                                // Nessuno slot libero
            rejected = true
            ERMSG = "Tutti_gli_slot_sono_gia_occupati"
          }
        } else {
          rejected = true
          ERMSG = "Capienza_stiva_non_sufficiente"
        }
      } else {
        rejected = true
        ERMSG = "Prodotto_non_registrato"
      }
      
    #]
    
    if [# rejected #] {
      println("$name : product rejected") color blue
      replyTo controlproduct with productrejected : productrejected($ERMSG)
    } else {
      println("$name : product accepted") color blue 
      [# waitingProduct = jsonObj #]
      replyTo controlproduct with productaccepted : productaccepted($SLOT)
    }
    
  }
} 
Transition t
whenEvent productloaded -> updateHoldState</code></pre><br/>

          Per la memorizzazione persistente dello
          stato della hold, data la sua semplicità e la limitata quantità di
          dati da gestire, è stato deciso di memorizzarne lo stato all'interno
          di un file JSON in quanto non richiede la creazione di nuovi
          componenti e risulta più semplice da implementare. Inoltre la gestione
          della persistenza tramite file json locale permette, in caso di
          necessità, anche agli altri attori del sistema di accedere facilmente
          alle informazioni riguardanti lo stato della hold. All'avvio del
          sistema l'holdmanager verificherà se il file esiste e in caso positivo
          caricherà lo stato della hold dalla memoria, in caso contrario si
          occuperà di creare il file ed inizializzarlo. Per avere una visione
          d'insieme del sistema nel file JSON verranno memorizzati 3 array, in
          cui ogni elemento corrisponde ad uno slot della hold:
          <ul>
            <li>
              pids : se il valore è 0 lo slot è libero, se maggiore di zero lo
              slot è occupato e il valore associato corrisponderà al PID del
              prodotto caricato in quello slot
            </li>
            <li>
              names: ogni elemento contiene il nome del prodotto caricato nello
              slot associato o una stringa vuota se lo slot è libero
            </li>
            <li>
              weights : ogni elemento corrisponde al peso del prodotto caricato
              nello slot associato, se il valore è 0 lo slot è libero. La somma
              di questi valori permetterà di ottenere il peso attuale della hold
            </li>
          </ul>
          Oltre a questi array nel file JSON verrà memorizzato anche
          <i>MAXLOAD</i>, cioè il peso massimo che la hold può sostenere
          <br />
          Il file JSON avrà dunque la seguente struttura:
<pre><code>{
  "pids": [0, 0, 0, 0],
  "names": ["", "", "", ""],
  "weights": [0, 0, 0, 0],
  "MAXLOAD": 100
}</code></pre>

          Nel momento in cui terminerà il caricamento del prodotto, holdmanager
          aggiornerà il contenuto del file JSON.
        </div>
      </div>

    </div>

      <h2>System Design</h2>

      <div class="medium-12 text-center remark">
        <img
          src="../sprint1_system_overviewarch.png"
          class="text-center"
          alt="map"
          width="100%"
        />

      </div>

      <footer class="footer">
        <div class="grid-container fluid">
          <div class="grid-x grid-margin-x align-middle">
            <div class="small-12 medium-3 text-center">
              <a
                class="button change"
                href="../../Sprint0/userDocs/sprint0_v3.html"
              >
                &larr; Previous Sprint
              </a>
            </div>

            <div class="small-12 medium-4 text-center">
              Fasano Andrea : andrea.fasano3@studio.unibo.it <br />
              <!-- 0001189592 -->
              Florian Alberto : alberto.florian@studio.unibo.it <br />
              <!-- 0001189572 -->
              Sampaoli Giacomo : giacomo.sampaoli@studio.unibo.it
              <!-- 0001176431 -->
            </div>

            <div class="small-12 medium-2 align-middle text-center">
              <a
                href="https://github.com/FlorAber/ISS25-cargoservice"
                class="button primary"
                target="_blank"
              >
                GitHub Repository
              </a>
            </div>

            <div class="small-12 medium-3 text-right">
              <a class="button change" href="../../Sprint2/userDocs/sprint2_v0.html"> Next Sprint &rarr; </a>
            </div>
          </div>
        </div>
      </footer>
    </div>
  </body>
</html>
