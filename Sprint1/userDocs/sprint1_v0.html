<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="it">
  <head>
    <!-- <script type="text/javascript" src="../css/issStyle.js"></script> -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"
      crossorigin="anonymous"
    ></script>
    <!-- <link rel="stylesheet" type="text/css" href="../../resources/_styles/style.css" /> -->
     <link rel="stylesheet" type="text/css" href="./css/style.css" />

    <title>ISS25 - Sprint 1</title>
    <style>
      .test-plan-table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
        background-color: #f4f4f4;
      }
      .test-plan-table th {
        background-color: #2c5f4f;
        color: white;
        padding: 12px;
        text-align: left;
        font-weight: bold;
        border: 1px solid #1a4538;
      }
      .test-plan-table td {
        padding: 10px 12px;
        border: 1px solid #ddd;
        background-color: white;
      }
      .test-plan-table tr:nth-child(even) td {
        background-color: #f9f9f9;
      }
      .test-plan-table tr:hover td {
        background-color: #e8f4f0;
      }
    </style>
  </head>

  <body>
    <div id="top">
      <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE - Sprint 1</h1>
    </div>
    <div class="body">
      <h2>Introduction</h2>
      <div class="remark">
        <div class="textbody grid-x grid-margin-x align-middle">
          <div class="medium-8">
            Nello
            <a href="../../Sprint0/userDocs/sprint0_v1.html">Sprint 0</a> è
            stato realizzato un primo modello del sistema ottenuto tramite la
            formalizzazione dei requisiti forniti dal committente (figura a
            destra). <br />
            <br />
            L'obiettivo dello Sprint 1 è di analizzare le problematiche del core
            business emerse nella fase di analisi dei requisiti e realizzarne
            un'implementazione funzionante da fornire al committente.
          </div>
          <div class="medium-4">
            <img
              src="../../Sprint0/sprint0_system_overviewarch.png"
              alt="architecture"
              width="75%"
            />
          </div>
        </div>
      </div>

      <h2>Requirements</h2>

      <div class="remark">
        <a
          href="../../resources/TemaFinale25.html"
          class="button primary"
          target="_blank"
        >
          Client requirements
        </a>
      </div>

      <h2> Info generali da aggiungere </h2>
      
      <div class="textparagraph">

          <h3>holdmanager</h3>
            <div class="textbody">
              È stato deciso di fare in modo che l'holdmanager mantenga lo stato della hold all'interno di varibaili locali, per rendere questa informazione 
              persistente così da poter avere una visione della hold in caso di crash del sistema nel momento in cui il caricamento di un prodotto viene completato (qua 
              da vedere se il robot invia un segnale di completamento quando torna alla home o in altro modo) oltre ad aggiornare lo stato interno questo viene 
              salvato all'interno di un file json così da essere visibile anche agli altri attori (es. GUI), per la GUI poi potremmo fare un altro attore o delegare all'cargomanager le richieste della GUI a seguito delle quali
              andrà a rispondere con il contenuto del JSON
          </div>

        </div>

      <h2>Problem analysis</h2>

      <div class="remark">

        Per seguire il single responsibility principle è stato deciso di affidare a diversi attori la gestione di parti diverse del sistema, 
        in seguito verranno specificati il comportamento di ciascun attore e le motivazioni dietro a queste scelte

        <div class="textparagraph">
          <h3>Come rappresentare la hold?</h3>
            <div class="textbody">
              Il robot rappresenta internamente la hold come un piano cartesiano.
              Questa viene quindi suddivisa in una griglia dove ciascuna cella è un quadrato avente lato pari alla dimensione del basicrobot, così da poter formalizzare il concetto di posizione, intesa come 
              una coppia di coordinate cartesiane. La home si troverà nel punto di origine, quindi alle coordinate (0,0) mentre i vari slot sono visibili nell'immagine seguente, che è analoga alla configurazione già presente all'interno del robot fornito dal committente e quindi non è modificabile. <br/>
              <div class="text-center"> <img src="resources/map.png" alt="grid" width="25%"/>  </div>
              In particolare si avranno: 
                <ul>
                  <li> Home alle coordinate (0,0)</li>
                  <li> Slot 1 alle coordinate (2,1) </li>
                  <li> Slot 2 alle coordinate (3,1) </li>
                  <li> Slot 3 alle coordinate (2,3) </li>
                  <li> Slot 4 alle coordinate (3,3) </li>
                  <li> Slot 5 alle coordinate (4,2) </li>
                </ul>
          </div>
        </div>

        <div class="textparagraph">
          <h3>Come muovere il basicrobot?</h3>
          <div class="textbody">
            Il basicrobot fornisce un'interfaccia che permette, tramite l'invio di messaggi, di controllarne il movimento.
            Per gestire questo movimento è stato deciso di introdurre un attore <bold> robotmanager </bold> che avrà il compito di controllare il robot in ogni suo movimento e gestire le interruzioni provenienti dal sonar in caso di malfunzionamento.
            Questo approccio consente di separare le funzionalità dei vari componenti facendo in modo che il cargomanager mantenga solo la funzionalità di gestore delle comunicazioni.

            <div class="textbody">
              <h4> Interazioni del robotmanager </h4>
              Dovendo controllare il robot in ogni suo movimento l'attore avvierà l'operazione di carico una volta ricevuto un messaggio dal cargomanager, questo messaggio 
              dovrà specificare lo slot a cui caricare il prodotto così che il robotmanager possa scegliere la strada appropriata per fare raggiungere al robot la posizione fisica.
              Una volta terminata l'operazione di caricamento il robotmanager invierà un messaggio al cargomanager per notificarlo.
              Inoltre l'attore deve essere capace di gestire i segnali di interruzione generati dal sonar (che arriveranno dal cargomanager in quanto gestore delle 
              comunicazioni) e fermare il movimento per poi farlo ripartire quando il sistema tornerà funzionante
            </div>

            <div class="textbody">
              <h4> Gestione del movimento </h4>
              Come fa muovere il robot?? Scriviamolo dopo averlo effettivamente fatto
            </div>

          </div>
        </div>

        <div class="textparagraph">
          <h3>Come sfruttare il productservice?</h3>
          <div class="textbody">
            Il productservice viene fornito dal componente e come si utilizza? ...
            Per sfruttare questo servizio e affidare ad un componente ad-hoc la gestione degli slot e del peso della nave cargo è stato deciso di implementare un attore di nome holdmanager.
            Questo attore fungerà da intermediario tra cargomanager e productservice, prendendo in carico la gestione della hold tramite il tracciamento degli slot liberi, di quelli occupati e del peso dei prodotti caricati nella nave cargo.
            A partire da queste conoscenze, al momento della ricezione di una richiesta getProduct dal cargomanager verifica se il prodotto è registrato, 
            verifica se il peso del prodotto è adeguato alla capacità massima della stiva e decide a che slot assegnare il carico (se sono presenti slot liberi). 
            Infine invierà una risposta al cargomanager specificando lo slot a cui caricare il prodotto in caso i controlli abbiano esito positivo o con un messaggio di errore motivazionale in caso contrario.
          </div>
        </div>

        <div class="textparagraph">
          <h3>Cosa fa il cargomanager?</h3>
          <div class="textbody"></div>
            Il cargomanager è l'attore che ha il compito di controllare il funzionamento del sistema e coordinare le comunicazioni tra i componenti.
            Al momento della ricezione di una richiesta di caricamento questa verrà inoltrata all'holdmanager e attende una risposta. 
            Al momento della ricezione della conferma risponderà al richiedente e, se la conferma è positiva, rimane in attesa del segnale di carico dal sonar.
            Al momento della ricezione del segnale dal sonar comuncherà al robotmanager lo slot, come indicato dall'holmanager, a cui portare il carico.
            Succesivamente attende il completamento delle operazioni del basicrobot prima di tornare in attesa di una nuova richiesta di carico.
            Oltre alla normale esecuzione il cargomanager dovrà gestire anche il segnali di interruzione provenienti dal sonar in caso di malfunzionamento 
            per andare a sospendere le attività di tutti i componenti del sistema fino al rientro dell'errore. 
          </div>
        </div>
      </div>

      <h2>Logical Architecture</h2>
      <div class="medium-12 text-center remark">
        <img
          src="../sprint1_system_overviewarch.png"
          class="text-center"
          alt="map"
          width="25%"
        />
      </div>

      <h2>Test plans</h2>
      <div class="remark">
        <div class="textbody">
          Lo scopo della fase di test è quello di testare il funzionamento del
          core business, cioè dei componenti <strong> cargomanager </strong> e
          <strong> productservice</strong>. Per farlo si è deciso di procedere
          inizialmente con un approccio Unit Test per poi proseguire con
          l'Integration Test al termine dei primi. <br />
          <ul>
            <li>
              Un'entità esterna andrà ad inoltrare una richiesta di carico al
              cargomanager e ne verficherà l'esito. Per rispondere a questa
              richiesta il cargomanager interagirà sempre con l'entità esterna
              che avrà il compito di simulare il comportamento del
              productservice. Se l'esito della richiesta sarà positivo l'entità
              esterna invierà un segnale di carico emulando il comportamento del
              sonar.
            </li>
            <li>
              Un'entità esterna avrà lo scopo di simulare il comportamento del
              cargomanager nella comunicazione con il productservice. Inviando
              appositi messaggi per effettuare la ricerca dei prodotti
              all'interno del database
            </li>
          </ul>
        </div>

        <div class="textbody">
          <table class="test-plan-table">
            <thead>
              <tr>
                <th>Test</th>
                <th>Attori</th>
                <th>Servizi</th>
                <th>Descrizione</th>
                <th>Modello</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Evento di richiesta caricamento</td>
                <td>MOCKActor; cargoManager;</td>
                <td></td>
                <td>Il QActor tester, simulando il MOCKActor, invia una richiesta di caricamento contenente il PID del prodotto al cargoManager</td>
                <td>test_interactions.qak<br/>CargoSystemTest.java</td>
              </tr>
              <tr>
                <td>Verifica prodotto registrato e peso</td>
                <td>cargoManager; holdManager;</td>
                <td>productService;</td>
                <td>Il cargoManager invia il PID ricevuto a holdManager che controlla, interrogando il productService, che il prodotto sia registrato e che il peso non superi il limite imposto dai vincoli. Invia un messaggio contenente lo slot in cui mettere il prodotto o un messaggio di errore a cargoManager.</td>
                <td>test_interactions.qak<br/>CargoSystemTest.java</td>
              </tr>
              <tr>
                <td>Arrivo di un carico</td>
                <td>MOCKActor; cargoManager; cargoRobot</td>
                <td></td>
                <td>Il QActor tester, simulando il MOCKActor, invia un messaggio a cargoManager quando rileva la presenza di un pacco contenente lo slot in cui depositare il pacco.</td>
                <td>test_interactions.qak<br/>CargoSystemTest.java</td>
              </tr>
              <tr>
                <td>Avvio del cargoRobot</td>
                <td>cargoManager; cargoRobot;</td>
                <td>basicRobot</td>
                <td>Il cargoManager invia al cargoRobot un messaggio contenente lo slot a cui andare/ le coordinate dello slot a cui andare. Quest'ultimo pilota il basicRobot.</td>
                <td>test_interactions.qak<br/>CargoSystemTest.java</td>
              </tr>
              <tr>
                <td>Fine caricamento</td>
                <td>cargoRobot; cargoManager</td>
                <td>basicRobot</td>
                <td>Il cargoRobot pilota il basicRobot fino alla HOME, manda un segnale a cargoManager che si rimette in ascolto di nuove richieste di carico.</td>
                <td><br/></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>



      <footer class="footer">
        <div class="grid-container fluid">
          <div class="grid-x grid-margin-x align-middle">
            <div class="small-12 medium-3 text-center">
              <a
                class="button change"
                href="../../Sprint0/userDocs/sprint0_v1.html"
              >
                &larr; Previous Sprint
              </a>
            </div>

            <div class="small-12 medium-4 text-center">
              Fasano Andrea : andrea.fasano3@studio.unibo.it <br />
              <!-- 0001189592 -->
              Florian Alberto : alberto.florian@studio.unibo.it <br />
              <!-- 0001189572 -->
              Sampaoli Giacomo : giacomo.sampaoli@studio.unibo.it
              <!-- 0001176431 -->
            </div>

            <div class="small-12 medium-2 align-middle text-center">
              <a
                href="https://github.com/FlorAber/ISS25-cargoservice"
                class="button primary"
                target="_blank"
              >
                GitHub Repository
              </a>
            </div>

            <div class="small-12 medium-3 text-right">
              <a class="button change disabled"> Next Sprint &rarr; </a>
            </div>
          </div>
        </div>
      </footer>
    </div>
  </body>
</html>