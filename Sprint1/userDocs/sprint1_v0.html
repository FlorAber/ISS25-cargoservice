<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="it">
  <head>
    <!-- <script type="text/javascript" src="../css/issStyle.js"></script> -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"
      crossorigin="anonymous"
    ></script>
    <!-- <link rel="stylesheet" type="text/css" href="../../resources/_styles/style.css" /> -->
    <link rel="stylesheet" type="text/css" href="./css/style.css" />

    <title>ISS25 - Sprint 1</title>
  </head>

  <body>
    <div id="top">
      <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE - Sprint 1</h1>
    </div>
    <div class="body">
      <h2>Introduction</h2>
      <div class="remark">
        <div class="textbody grid-x grid-margin-x align-middle">
          <div class="medium-8">
            Nello
            <a href="../../Sprint0/userDocs/sprint0_v1.html">Sprint 0</a> è
            stato realizzato un primo modello del sistema ottenuto tramite la
            formalizzazione dei requisiti forniti dal committente (figura a
            destra). <br />
            <br />
            L'obiettivo dello Sprint 1 è di analizzare le problematiche del core
            business emerse nella fase di analisi dei requisiti e realizzarne
            un'implementazione funzionante da fornire al committente.
          </div>
          <div class="medium-4">
            <img
              src="../../Sprint0/sprint0_system_overviewarch.png"
              alt="architecture"
              width="75%"
            />
          </div>
        </div>
      </div>

      <h2>Requirements</h2>

      <div class="remark">
        <a
          href="../../resources/TemaFinale25.html"
          class="button primary"
          target="_blank"
        >
          Client requirements
        </a>
      </div>

      <h2>Problem analysis</h2>

      <div class="remark">
        Per seguire il single responsibility principle è stato deciso di
        affidare a diversi attori la gestione delle distinte parti del sistema,
        in seguito verranno specificati il comportamento di ciascun attore e le
        motivazioni dietro a queste scelte

        <div class="textparagraph">
          <h3>Come muovere il basicrobot?</h3>
          <div class="textbody">
            Il basicrobot fornisce un'interfaccia che permette, tramite l'invio
            di messaggi, di controllarne il movimento. Per gestire questo
            movimento è stato deciso di introdurre un attore
            <strong> cargorobot </strong> che avrà il compito di controllare il
            robot in ogni suo movimento e gestire le interruzioni provenienti
            dal sonar in caso di malfunzionamento. Questo approccio consente di
            separare le funzionalità dei vari componenti facendo in modo che il
            cargoservice mantenga solo la funzionalità di gestore delle
            comunicazioni.

            <div class="textbody">
              <h4>Interazioni del cargorobot</h4>
              Dovendo controllare il robot in ogni suo movimento l'attore
              avvierà l'operazione di carico una volta ricevuto un messaggio dal
              cargoservice, questo messaggio dovrà specificare lo slot a cui
              caricare il prodotto così che il cargorobot possa scegliere la
              strada appropriata per fare raggiungere al robot la posizione
              fisica. Una volta terminata l'operazione di caricamento il
              cargorobot invierà un messaggio al cargoservice per notificarlo
              dell'avvenuto caricamento. Inoltre l'attore deve essere capace di
              gestire i segnali di interruzione generati dal sonar (che
              arriveranno dal cargoservice in quanto gestore delle
              comunicazioni) e fermare il movimento per poi farlo ripartire
              quando il sistema tornerà funzionante
            </div>

            <div class="textbody">
              <h4>Gestione del movimento</h4>
              Il basicrobot mette a disposizione diversi messaggi per muovere il
              DDR robot. Sono stati identificati due messaggi principali che
              permettono di definire un piano di esecuzione per spostare il
              robot da un punto A ad un punto B.
              <div>
                <table class="robot-table">
                  <thead>
                    <tr>
                      <th>Messaggio</th>
                      <th>Funzionamento</th>
                      <th>Componenti</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>moverobot(TARGETX, TARGETY)</td>
                      <td>
                        Gestisce le richieste di posizionamento, determina il
                        piano di movimento, restituisce moverobotdone, se ok,
                        moverobotfailed, se errore.
                      </td>
                      <td>planexec, robotpos</td>
                      <td>
                        Gestisce anche il comando di utilità setpos(X,Y,D) per
                        allienare la rappresentazione del planner sulla
                        posizione corrente reale del robot fissata manualmente.
                      </td>
                    </tr>
                    <tr>
                      <td>doplan(PATH, STEPTIME)</td>
                      <td>
                        Gestisce richieste di esecuzione di una serie di mosse,
                        restituisce doplandone, se ok, doplanfailed, se errore.
                      </td>
                      <td>planexec</td>
                      <td>Non usa e non aggiorna alcuna mappa della stanza</td>
                    </tr>
                  </tbody>
                </table>
              </div>
               <br />
            </div>

            <div class="textbody">
              <h4>Come recuperare le coordinate?</h4>
              risulta fondamentale la possibilità di recuperare le coordinate dei punti di interesse all'interno della hold,
              sono stati identificati due possibili approcci:
              <ul>
                <li>Memorizzazione delle coordinate all'interno del sistema</li>
                <li>
                  Memorizzazione delle coordinate in una base di conoscenza
                  prolog
                </li>
              </ul>
            </div>
          </div>
        </div>

        <div class="textparagraph">
          <h3>Come sfruttare il productservice e gestire la hold?</h3>
          <div class="textbody">
            Lo stato della hold (slot liberi e peso della nave cargo) deve
            essere gestito da uno degli attori del sistema; per fare in modo che
            il cargoservice mantenga solo la funzionalità di gestore delle
            comunicazioni è stato deciso di affidare questa responsabilità ad un
            attore dedicato di nome <strong> holdmanager </strong>, il quale si
            occuperà anche dell'interfacciamnento con il
            <strong> productservice </strong>. Il productservice viene fornito
            dal committente e permette di recuperare le informazioni riguardanti
            un prodotto tramite l'invio di un messaggio
            <strong> getProduct </strong> nel quale viene specificato il PID del
            prodotto da ricercare.
            <br />

            Questo attore <strong> holdmanager </strong> fungerà da
            intermediario tra il cargoservice e il productservice, prendendo in
            carico la gestione della hold tramite il tracciamento degli slot
            liberi, di quelli occupati e del peso dei prodotti caricati nella
            nave cargo. A partire da queste conoscenze, al momento della
            ricezione di una richiesta <i>controlproduct(pid)</i> proventiente dal cargoservice
            sfrutterà il productservice per verificare se il prodotto è
            registrato, successivamente verificherà se il peso del prodotto è
            adeguato alla capacità massima della stiva e deciderà a che slot
            assegnare il carico (se sono presenti slot liberi). Infine invierà
            una risposta al cargoservice specificando lo slot a cui caricare il
            prodotto (in caso i controlli abbiano avuto esito positivo) o con un
            messaggio di errore motivazionale in caso contrario.

            <div class="textbody">
              <h4>Tracciamento del carico</h4>
              Il tracciamento del carico potrà avvenire in due modi:
              <ul>
                <li>Tracciamento persistente</li>
                <li>Tracciamento non persistente</li>
              </ul>

              Per avere una visione dello stato della hold anche in caso di
              crash del sistema è stato deciso di seguire il primo approccio, il
              quale porta a dover prendere un'ulteriore decisione su come
              gestire la persistenza, le alternative identificate sono:
              <ul>
                <li>Utilizzare un file json</li>
                <li>Utilizzare un database leggero (es. SQLite)</li>
              </ul>

              Data la semplicità della hold e la limitata quantità di dati da
              gestire si è optato per la prima soluzione in quanto non richiede
              la creazione di nuovi componenti e risulta più semplice da
              implementare. Inoltre la gestione della persistenza tramite file
              json locale permette, in caso di necessità, anche agli altri
              attori del sistema di accedere facilmente alle informazioni
              riguardanti lo stato della hold. All'avvio del sistema
              l'holdmanager verificherà se il file esiste e in caso positivo
              caricherà lo stato della hold dalla memoria, in caso contrario si
              occuperà di creare il file ed inizializzarlo.
            </div>
          </div>
        </div>
      </div>

      <h2>System Design</h2>
      <div class="medium-12 text-center remark">
        <img
          src="../sprint1_system_overviewarch.png"
          class="text-center"
          alt="map"
          width="100%"
        />
      </div>

      <h2>Test plans</h2>
      <div class="remark">
        <div class="textbody">
          Lo scopo della fase di test è quello di verificare il funzionamento
          del core business, cioè dei componenti
          <strong> cargoservice </strong>, <strong> productservice</strong> e
          <strong> cargorobot </strong>.

          <div class="textbody">
            <table class="test-plan-table">
              <thead>
                <tr>
                  <th>Test</th>
                  <th>Attori</th>
                  <th>Servizi</th>
                  <th>Descrizione</th>
                  <th>Modello</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Evento di richiesta caricamento</td>
                  <td>MOCKActor; cargoservice;</td>
                  <td></td>
                  <td>
                    Il QActor tester, simulando il MOCKActor, invia una
                    richiesta di caricamento contenente il PID del prodotto al
                    cargoservice
                  </td>
                  <td>test_interactions.qak<br />CargoSystemTest.java</td>
                </tr>
                <tr>
                  <td>Verifica prodotto registrato e peso</td>
                  <td>cargoservice; holdManager;</td>
                  <td>productService;</td>
                  <td>
                    Il cargoservice invia il PID ricevuto a holdManager che
                    controlla, interrogando il productService, che il prodotto
                    sia registrato e che il peso non superi il limite imposto
                    dai vincoli. Invia un messaggio contenente lo slot in cui
                    mettere il prodotto o un messaggio di errore a cargoservice.
                  </td>
                  <td>test_interactions.qak<br />CargoSystemTest.java</td>
                </tr>
                <tr>
                  <td>Arrivo di un carico</td>
                  <td>MOCKActor; cargoservice; cargoRobot</td>
                  <td></td>
                  <td>
                    Il QActor tester, simulando il MOCKActor, invia un messaggio
                    a cargoservice quando rileva la presenza di un pacco
                    contenente lo slot in cui depositare il pacco.
                  </td>
                  <td>test_interactions.qak<br />CargoSystemTest.java</td>
                </tr>
                <tr>
                  <td>Avvio del cargoRobot</td>
                  <td>cargoservice; cargoRobot;</td>
                  <td>basicRobot</td>
                  <td>
                    Il cargoservice invia al cargoRobot un messaggio contenente
                    lo slot a cui andare/ le coordinate dello slot a cui andare.
                    Quest'ultimo pilota il basicRobot.
                  </td>
                  <td>test_interactions.qak<br />CargoSystemTest.java</td>
                </tr>
                <tr>
                  <td>Fine caricamento</td>
                  <td>cargoRobot; cargoservice</td>
                  <td>basicRobot</td>
                  <td>
                    Il cargoRobot pilota il basicRobot fino alla HOME, manda un
                    segnale a cargoservice che si rimette in ascolto di nuove
                    richieste di carico.
                  </td>
                  <td><br /></td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <h2>Project</h2>
      <div class="remark">
        <div class="textparagraph">
          <h3>Rappresentazione della hold</h3>
          <div class="textbody">
            Il robot rappresenta internamente la hold come un piano cartesiano.
            Questa viene quindi suddivisa in una griglia dove ciascuna cella è
            un quadrato avente lato pari alla dimensione del basicrobot, così da
            poter formalizzare il concetto di posizione, intesa come una coppia
            di coordinate cartesiane. La home si troverà nel punto di origine,
            quindi alle coordinate (0,0) mentre i vari slot sono visibili
            nell'immagine seguente, che è analoga alla configurazione già
            presente all'interno del robot fornito dal committente e per questo
            non è modificabile.
            <br />
            <div class="text-center">
              <img src="resources/map.png" alt="grid" width="25%" />
            </div>
            In particolare si avranno:
            <ul>
              <li>Home alle coordinate (0,0)</li>
              <li>Slot 1 alle coordinate (2,1)</li>
              <li>Slot 2 alle coordinate (3,1)</li>
              <li>Slot 3 alle coordinate (2,3)</li>
              <li>Slot 4 alle coordinate (3,3)</li>
              <li>Slot 5 alle coordinate (4,2)</li>
              <li>
                Come scelta progettuale, non essendo specificata nella mappa
                data dal committente, è stato deciso di posizionare la IOPort
                alle coordinate (1,5)
              </li>
            </ul>
          </div>
        </div>

        <div class="textparagraph">
          <h3>comportamento del cargoservice</h3>
          <div class="textbody">
            Il cargoservice è l'attore che ha il compito di controllare il
          funzionamento del sistema e coordinare le comunicazioni tra i diversi
          componenti. Al momento della ricezione di una richiesta di caricamento da parte dell'utente, contenente
          il PID del prodotto che intende depositare,
          verrà inviata all'<strong>holdmanager</strong> una richiesta <i>controlproduct(pid)</i>, rimanendo dunque in
          attesa di una risposta corrispondente all'esito, <i>productaccepted(slot)</i> o <i>productrejected()</i>
          conseguenti ai controlli di cui è responsabile <strong>holdmanager</strong>.
          Al momento della ricezione della risposta
          comunicherà all'utente l'esito e, se sarà positivo, rimarrà in
          attesa del segnale di carico proveniente dal sonar, in caso contrario
          tornerà nello stato di attesa delle richieste di carico. Al momento
          della ricezione del segnale dal sonar comunicherà al
          <strong>cargorobot</strong> tramite richiesta <i>load(slot)</i> lo slot precedentemente indicato dall'<strong>holdmanager</strong> 
          in cui andare a depositare il prodotto. Successivamente attenderà il completamento
          delle operazioni del <strong>cargorobot</strong>, il quale risponderà con <i>loadended()</i> in caso
          di successo o <i>loadfailed()</i> in caso di errore,
          prima di tornare in
          attesa di una nuova richiesta di carico. <br />

          Oltre al suo normale flusso di esecuzione, il cargoservice dovrà
          gestire i segnali di interruzione provenienti dal sonar in caso di
          malfunzionamento, così da andare a sospendere le attività di tutti i
          componenti del sistema fino al rientro dell'errore
          </div>
          
        </div>
      

      <div class="textparagraph">
          <h3>comportamento del cargorobot</h3>
          <div class="textbody">
            Per muovere il DDR robot è stato deciso di utilizzare il messaggio
              <i>moverobot(TARGETX, TARGETY)</i>. Questo perchè permette di
              semplificare lo sviluppo delegando le operazioni di scelta del
              percorso da eseguire al basicrobot.
          Dunque il cargorobot ha essenzialmente il compito di tradurre 
          lo slot ricevuto tramite richiesta <i>load(slot)</i> in coordinate
          assolute. A questo fine è stato deciso di sfruttare il secondo approccio
          indicato in fase di analisi ovvero sfruttare una base di conoscenza
          prolog, in quanto più flessibile e scalabile in caso di modifiche future alla
          mappa. Sfruttando questa base di conoscenza il cargorobot potrà
          comunicare le coordinate relative alle posizioni al basicrobot. Nella base di conoscenza sono definiti dei predicati del tipo:
          <i>position(X, Y, DIR, P).</i>
          che associano a ciascun punto della mappa (come slot, home, ioport)
           le coordinate assolute (X, Y) e la direzione DIR.
            Il predicato di accesso:
             <i>getPoint(P, X, Y, DIR) :- position(X, Y, DIR, P).</i>
          consente al cargorobot di ottenere le coordinate e la direzione relative a una determinata posizione P.
              <ul>
                <li>x: ascissa del punto</li>
                <li>y: ordinata del punto</li>
                <li>
                  direzione: permetterà di ruotare il robot verso la posizione
                  rilevante di interesse
                </li>
              </ul>

          </div>
          
        </div>
      </div>

      <footer class="footer">
        <div class="grid-container fluid">
          <div class="grid-x grid-margin-x align-middle">
            <div class="small-12 medium-3 text-center">
              <a
                class="button change"
                href="../../Sprint0/userDocs/sprint0_v1.html"
              >
                &larr; Previous Sprint
              </a>
            </div>

            <div class="small-12 medium-4 text-center">
              Fasano Andrea : andrea.fasano3@studio.unibo.it <br />
              <!-- 0001189592 -->
              Florian Alberto : alberto.florian@studio.unibo.it <br />
              <!-- 0001189572 -->
              Sampaoli Giacomo : giacomo.sampaoli@studio.unibo.it
              <!-- 0001176431 -->
            </div>

            <div class="small-12 medium-2 align-middle text-center">
              <a
                href="https://github.com/FlorAber/ISS25-cargoservice"
                class="button primary"
                target="_blank"
              >
                GitHub Repository
              </a>
            </div>

            <div class="small-12 medium-3 text-right">
              <a class="button change disabled"> Next Sprint &rarr; </a>
            </div>
          </div>
        </div>
      </footer>
    </div>
  </body>
</html>
