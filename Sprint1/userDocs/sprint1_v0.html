<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="it">
  <head>
    <!-- <script type="text/javascript" src="../css/issStyle.js"></script> -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"
      crossorigin="anonymous"
    ></script>
    <!-- <link rel="stylesheet" type="text/css" href="../../resources/_styles/style.css" /> -->
    <link rel="stylesheet" type="text/css" href="./css/style.css" />

    <title>ISS25 - Sprint 1</title>
  </head>

  <body>
    <div id="top">
      <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE - Sprint 1</h1>
    </div>
    <div class="body">
      <h2>Introduction</h2>
      <div class="remark">
        <div class="textbody grid-x grid-margin-x align-middle">
          <div class="medium-8">
            Nello
            <a href="../../Sprint0/userDocs/sprint0_v1.html">Sprint 0</a> è
            stato realizzato un primo modello del sistema ottenuto tramite la
            formalizzazione dei requisiti forniti dal committente (figura a
            destra). <br />
            <br />
            L'obiettivo dello Sprint 1 è di analizzare le problematiche del core
            business emerse nella fase di analisi dei requisiti e realizzarne
            un'implementazione funzionante da fornire al committente.
          </div>
          <div class="medium-4">
            <img
              src="../../Sprint0/sprint0_system_overviewarch.png"
              alt="architecture"
              width="75%"
            />
          </div>
        </div>
      </div>

      <h2>Requirements</h2>

      <div class="remark">
        <a
          href="../../resources/TemaFinale25.html"
          class="button primary"
          target="_blank"
        >
          Client requirements
        </a>
      </div>

      <h2>Problem analysis</h2>

      <div class="remark">
        Per seguire il single responsibility principle è stato deciso di
        affidare a diversi attori la gestione delle distinte parti del sistema,
        in seguito verranno specificati il comportamento di ciascun attore e le
        motivazioni dietro a queste scelte

        <div class="textparagraph">
          <h3>Come rappresentare la hold?</h3>
          <div class="textbody">
            Il robot rappresenta internamente la hold come un piano cartesiano.
            Questa viene quindi suddivisa in una griglia dove ciascuna cella è
            un quadrato avente lato pari alla dimensione del basicrobot, così da
            poter formalizzare il concetto di posizione, intesa come una coppia
            di coordinate cartesiane. La home si troverà nel punto di origine,
            quindi alle coordinate (0,0) mentre i vari slot sono visibili
            nell'immagine seguente, che è analoga alla configurazione già
            presente all'interno del robot fornito dal committente e per questo
            non è modificabile. <br />
            <div class="text-center">
              <img src="resources/map.png" alt="grid" width="25%" />
            </div>
            In particolare si avranno:
            <ul>
              <li>Home alle coordinate (0,0)</li>
              <li>Slot 1 alle coordinate (2,1)</li>
              <li>Slot 2 alle coordinate (3,1)</li>
              <li>Slot 3 alle coordinate (2,3)</li>
              <li>Slot 4 alle coordinate (3,3)</li>
              <li>Slot 5 alle coordinate (4,2)</li>
              <li>
                Come scelta progettuale, non essendo specificata nella mappa
                data dal committente, è stato deciso di posizionare la IOPort
                alle coordinate (1,5)
              </li>
            </ul>
          </div>
        </div>

        <div class="textparagraph">
          <h3>Come muovere il basicrobot?</h3>
          <div class="textbody">
            Il basicrobot fornisce un'interfaccia che permette, tramite l'invio
            di messaggi, di controllarne il movimento. Per gestire questo
            movimento è stato deciso di introdurre un attore
            <strong> robotmanager </strong> che avrà il compito di controllare
            il robot in ogni suo movimento e gestire le interruzioni provenienti
            dal sonar in caso di malfunzionamento. Questo approccio consente di
            separare le funzionalità dei vari componenti facendo in modo che il
            cargomanager mantenga solo la funzionalità di gestore delle
            comunicazioni.

            <div class="textbody">
              <h4>Interazioni del robotmanager</h4>
              Dovendo controllare il robot in ogni suo movimento l'attore
              avvierà l'operazione di carico una volta ricevuto un messaggio dal
              cargomanager, questo messaggio dovrà specificare lo slot a cui
              caricare il prodotto così che il robotmanager possa scegliere la
              strada appropriata per fare raggiungere al robot la posizione
              fisica. Una volta terminata l'operazione di caricamento il
              robotmanager invierà un messaggio al cargomanager per notificarlo.
              Inoltre l'attore deve essere capace di gestire i segnali di
              interruzione generati dal sonar (che arriveranno dal cargomanager
              in quanto gestore delle comunicazioni) e fermare il movimento per
              poi farlo ripartire quando il sistema tornerà funzionante
            </div>

            <div class="textbody">
              <h4>Gestione del movimento</h4>
              Il committente fornisce il software del basicrobot che mette a
              disposizione un messaggio moverobot(TARGETX, TARGETY). Questo
              messaggio in base alle coordinate inserite muoverà il basicrobot
              verso di esse in modo automatico. Per recuperare le coordinate di
              ogni parte rilevante del sistema useremo una base di conoscenza
              prolog. Sfruttando questa base di conoscenza il cargorobot potrà
              comunicare le coordinate relative alle posizioni al basicrobot. Il
              predicato prolog creato prenderà in ingresso due variabili libere
              x, y e una direzione, unificando la posizione che fa match:
              <ul>
                <li>x: ascissa del punto</li>
                <li>y: ordinata del punto</li>
                <li>
                  direzione: permetterà di ruotare il robot verso la posizione
                  rilevante di interesse
                </li>
              </ul>
            </div>
          </div>
        </div>

        <div class="textparagraph">
          <h3>Come sfruttare il productservice e gestire la hold?</h3>
          <div class="textbody">
            Il productservice viene fornito dal committente e permette di
            recuperare le informazioni riguardanti un prodotto tramite l'invio
            di un messaggio <strong> getProduct </strong> nel quale viene
            specificato il PID del prodotto da ricercare.
            <br />
            Per sfruttare questo servizio e affidare ad un componente ad-hoc la
            gestione degli slot e del peso della nave cargo è stato deciso di
            implementare un attore di nome <strong> holdmanager </strong>.
            <br />
            Questo attore fungerà da intermediario tra il cargomanager e il
            productservice, prendendo in carico la gestione della hold tramite
            il tracciamento degli slot liberi, di quelli occupati e del peso dei
            prodotti caricati nella nave cargo. A partire da queste conoscenze,
            al momento della ricezione di una richiesta getProduct dal
            cargomanager sfrutterà il productservice per verificare se il
            prodotto è registrato, successivamente verificherà se il peso del
            prodotto è adeguato alla capacità massima della stiva e deciderà a
            che slot assegnare il carico (se sono presenti slot liberi). Infine
            invierà una risposta al cargomanager specificando lo slot a cui
            caricare il prodotto in caso i controlli abbiano esito positivo o
            con un messaggio di errore motivazionale in caso contrario.
            <div class="textbody">
              <h4>Tracciamento del carico</h4>
              L'holdmanager manterrà lo stato della hold all'interno di alcune
              variabili locali. Per rendere questa informazione persistente,
              così da poter avere una visione dello stato della hold anche in
              caso di crash del sistema, al termine dei ogni caricamento lo
              stato interno dell'holdmanager verrà salvato all'interno di un
              file json. All'avvio del sistema l'holdmanager verificherà se il
              file esiste e in caso positivo caricherà lo stato della hold dalla
              memoria, in caso contrario si occuperà di crearlo ed
              inizializzarlo.
            </div>
          </div>
        </div>

        <div class="textparagraph">
          <h3>Cosa fa il cargomanager?</h3>
          <div class="textbody"></div>
          Il cargomanager è l'attore che ha il compito di controllare il
          funzionamento del sistema e coordinare le comunicazioni tra i diversi
          componenti. Al momento della ricezione di una richiesta di caricamento
          questa verrà inoltrata all'<strong>holdmanager</strong>, rimanendo in
          attesa una risposta. Al momento della ricezione della risposta
          risponderà al richiedente e, se la risposta sarà positiva, rimarrà in
          attesa del segnale di carico proveniente dal sonar, in caso contrario
          tornerà nello stato di attesa delle richieste di carico. Al momento
          della ricezione del segnale dal sonar comunicherà al
          <strong>cargorobot</strong> lo slot indicato dall'<strong
            >holmanager</strong
          >
          a cui portare il carico. Successivamente attenderà il completamento
          delle operazioni del <strong>robotmanager</strong> prima di tornare in
          attesa di una nuova richiesta di carico. <br />

          Oltre al suo normale flusso di esecuzione, il cargomanager dovrà
          gestire i segnali di interruzione provenienti dal sonar in caso di
          malfunzionamento, così da andare a sospendere le attività di tutti i
          componenti del sistema fino al rientro dell'errore
        </div>
      </div>
    </div>

    <h2>Logical Architecture</h2>
    <div class="medium-12 text-center remark">
      <img
        src="../sprint1_system_overviewarch.png"
        class="text-center"
        alt="map"
        width="100%"
      />
    </div>

    <h2>Test plans</h2>
    <div class="remark">
      <div class="textbody">
        Lo scopo della fase di test è quello di verificare il funzionamento del
        core business, cioè dei componenti <strong> cargomanager </strong>,
        <strong> productservice</strong> e <strong> cargorobot </strong>.

        <div class="textbody">
          <table class="test-plan-table">
            <thead>
              <tr>
                <th>Test</th>
                <th>Attori</th>
                <th>Servizi</th>
                <th>Descrizione</th>
                <th>Modello</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Evento di richiesta caricamento</td>
                <td>MOCKActor; cargoManager;</td>
                <td></td>
                <td>
                  Il QActor tester, simulando il MOCKActor, invia una richiesta
                  di caricamento contenente il PID del prodotto al cargoManager
                </td>
                <td>test_interactions.qak<br />CargoSystemTest.java</td>
              </tr>
              <tr>
                <td>Verifica prodotto registrato e peso</td>
                <td>cargoManager; holdManager;</td>
                <td>productService;</td>
                <td>
                  Il cargoManager invia il PID ricevuto a holdManager che
                  controlla, interrogando il productService, che il prodotto sia
                  registrato e che il peso non superi il limite imposto dai
                  vincoli. Invia un messaggio contenente lo slot in cui mettere
                  il prodotto o un messaggio di errore a cargoManager.
                </td>
                <td>test_interactions.qak<br />CargoSystemTest.java</td>
              </tr>
              <tr>
                <td>Arrivo di un carico</td>
                <td>MOCKActor; cargoManager; cargoRobot</td>
                <td></td>
                <td>
                  Il QActor tester, simulando il MOCKActor, invia un messaggio a
                  cargoManager quando rileva la presenza di un pacco contenente
                  lo slot in cui depositare il pacco.
                </td>
                <td>test_interactions.qak<br />CargoSystemTest.java</td>
              </tr>
              <tr>
                <td>Avvio del cargoRobot</td>
                <td>cargoManager; cargoRobot;</td>
                <td>basicRobot</td>
                <td>
                  Il cargoManager invia al cargoRobot un messaggio contenente lo
                  slot a cui andare/ le coordinate dello slot a cui andare.
                  Quest'ultimo pilota il basicRobot.
                </td>
                <td>test_interactions.qak<br />CargoSystemTest.java</td>
              </tr>
              <tr>
                <td>Fine caricamento</td>
                <td>cargoRobot; cargoManager</td>
                <td>basicRobot</td>
                <td>
                  Il cargoRobot pilota il basicRobot fino alla HOME, manda un
                  segnale a cargoManager che si rimette in ascolto di nuove
                  richieste di carico.
                </td>
                <td><br /></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <footer class="footer">
        <div class="grid-container fluid">
          <div class="grid-x grid-margin-x align-middle">
            <div class="small-12 medium-3 text-center">
              <a
                class="button change"
                href="../../Sprint0/userDocs/sprint0_v1.html"
              >
                &larr; Previous Sprint
              </a>
            </div>

            <div class="small-12 medium-4 text-center">
              Fasano Andrea : andrea.fasano3@studio.unibo.it <br />
              <!-- 0001189592 -->
              Florian Alberto : alberto.florian@studio.unibo.it <br />
              <!-- 0001189572 -->
              Sampaoli Giacomo : giacomo.sampaoli@studio.unibo.it
              <!-- 0001176431 -->
            </div>

            <div class="small-12 medium-2 align-middle text-center">
              <a
                href="https://github.com/FlorAber/ISS25-cargoservice"
                class="button primary"
                target="_blank"
              >
                GitHub Repository
              </a>
            </div>

            <div class="small-12 medium-3 text-right">
              <a class="button change disabled"> Next Sprint &rarr; </a>
            </div>
          </div>
        </div>
      </footer>
    </div>
  </body>
</html>
