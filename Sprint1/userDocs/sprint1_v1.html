<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="it">
  <head>
    <!-- <script type="text/javascript" src="../css/issStyle.js"></script> -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"
      crossorigin="anonymous"
    ></script>
    <!-- <link rel="stylesheet" type="text/css" href="../../resources/_styles/style.css" /> -->
    <link rel="stylesheet" type="text/css" href="./css/style.css" />

    <title>ISS25 - Sprint 1</title>
  </head>

  <body>
    <div id="top">
      <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE - Sprint 1</h1>
    </div>
    <div class="body">
      <h2>Introduction</h2>
      <div class="remark">
        <div class="textbody grid-x grid-margin-x align-middle">
          <div class="medium-8">
            Nello
            <a href="../../Sprint0/userDocs/sprint0_v1.html">Sprint 0</a> è
            stato realizzato un primo modello del sistema ottenuto tramite la
            formalizzazione dei requisiti forniti dal committente (figura a
            destra). <br />
            <br />
            L'obiettivo dello Sprint 1 è di analizzare le problematiche del core
            business emerse nella fase di analisi dei requisiti e realizzarne
            un'implementazione funzionante da fornire al committente.
          </div>
          <div class="medium-4">
            <img
              src="../../Sprint0/sprint0_system_overviewarch.png"
              alt="Sprint 0 architecture"
              width="75%"
            />
          </div>
        </div>
      </div>

      <h2>Requirements</h2>

      <div class="remark">
        <a
          href="../../resources/TemaFinale25.html"
          class="button primary"
          target="_blank"
        >
          Client requirements
        </a>
      </div>

      <h2>Problem analysis</h2>

      <div class="remark">
        Per seguire il single responsibility principle è stato deciso di
        affidare a diversi attori la gestione delle distinte parti del sistema,
        in seguito verranno specificati il comportamento di ciascun attore e le
        motivazioni dietro a queste scelte

        <div class="textparagraph">
          <h3>Come muovere il basicrobot?</h3>
          <div class="textbody">
            Il basicrobot fornisce un'interfaccia che permette, tramite l'invio
            di messaggi, di controllarne il movimento. Per gestire questo
            movimento è stato deciso di introdurre un attore
            <strong> cargorobot </strong> che avrà il compito di controllare il
            robot in ogni suo movimento e gestire le interruzioni provenienti
            dal sonar in caso di malfunzionamento. Questo approccio consente di
            separare le funzionalità dei vari componenti facendo in modo che il
            cargoservice mantenga solo la funzionalità di gestore delle
            comunicazioni.

            <div class="textbody">
              <h4>Interazioni del cargorobot</h4>
              Dovendo controllare il robot, l'attore avvierà l'operazione di
              carico una volta ricevuto un messaggio dal cargoservice, questo
              messaggio dovrà specificare lo slot a cui caricare il prodotto
              così che il cargorobot possa scegliere la strada appropriata per
              fare raggiungere al robot la giusta posizione fisica. Una volta
              terminato lo spostamento il cargorobot invierà un messaggio al
              cargoservice per notificarlo dell'avvenuto caricamento. Inoltre
              l'attore deve essere capace di gestire i segnali di interruzione
              generati dal sonar (che arriveranno dal cargoservice in quanto
              gestore delle comunicazioni) fermando il robot e facendolo
              ripartire quando il sistema tornerà funzionante.
            </div>

            <div class="textbody">
              <br />
              <h4>Gestione del movimento</h4>
              Il basicrobot mette a disposizione diversi messaggi per muovere il
              DDR robot. Sono stati identificati due messaggi principali che
              permettono di definire un piano di esecuzione per spostare il
              robot da un punto A ad un punto B.
              <table class="robot-table">
                <thead>
                  <tr>
                    <th>Messaggio</th>
                    <th>Funzionamento</th>
                    <th>Componenti</th>
                    <th>Note</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>moverobot(TARGETX, TARGETY)</td>
                    <td>
                      Gestisce le richieste di posizionamento, determina il
                      piano di movimento, restituisce moverobotdone, se ok,
                      moverobotfailed, se errore.
                    </td>
                    <td>planexec, robotpos</td>
                    <td>
                      Gestisce anche il comando di utilità setpos(X,Y,D) per
                      allienare la rappresentazione del planner sulla posizione
                      corrente reale del robot fissata manualmente.
                    </td>
                  </tr>
                  <tr>
                    <td>doplan(PATH, STEPTIME)</td>
                    <td>
                      Gestisce richieste di esecuzione di una serie di mosse,
                      restituisce doplandone, se ok, doplanfailed, se errore.
                    </td>
                    <td>planexec</td>
                    <td>Non usa e non aggiorna alcuna mappa della stanza</td>
                  </tr>
                </tbody>
              </table>
              Per semplificare lo sviluppo delegando le operazioni di scelta del
              percorso da eseguire al basicrobot, il quale è munito di un
              sistema automatico di pianificazioned del percorso, è stato deciso
              di utilizzare il messaggio <i>moverobot(TARGETX, TARGETY)</i>. Il
              cargorobot dovrà dunque essere in grado di tradurre
              l'identificatore dello slot ricevuto nelle rispettive coordinate
              assolute.
            </div>
            <br />
            <div class="textbody">
              <h4>Come recuperare le coordinate?</h4>
              risulta fondamentale la possibilità di recuperare le coordinate
              dei punti di interesse all'interno della hold, sono stati
              identificati due possibili approcci:
              <ul>
                <li>Memorizzazione delle coordinate all'interno del sistema</li>
                <li>
                  Memorizzazione delle coordinate in una base di conoscenza
                  prolog
                </li>
              </ul>

              A questo fine è stato deciso di sfruttare il secondo approccio in
              quanto più flessibile e scalabile in caso di modifiche future alla
              mappa.
            </div>
          </div>
        </div>

        <div class="textparagraph">
          <h3>Come sfruttare il productservice e gestire la hold?</h3>
          <div class="textbody">
            Lo stato della hold (slot liberi e peso della nave cargo) deve
            essere gestito da uno degli attori del sistema; per fare in modo che
            il cargoservice mantenga solo la funzionalità di gestore delle
            comunicazioni è stato deciso di affidare questa responsabilità ad un
            attore dedicato di nome <strong> holdmanager </strong>, il quale si
            occuperà anche dell'interfacciamento con il
            <strong> productservice </strong>. Il productservice viene fornito
            dal committente e permette di recuperare le informazioni riguardanti
            un prodotto tramite l'invio di un messaggio
            <strong> getProduct </strong> nel quale viene specificato il PID del
            prodotto da ricercare.
            <br />

            Questo attore <strong> holdmanager </strong> fungerà da
            intermediario tra il cargoservice e il productservice, prendendo in
            carico la gestione della hold tramite il tracciamento degli slot
            liberi, di quelli occupati e del peso dei prodotti caricati nella
            nave cargo.

            <div class="textbody">
              <h4>Tracciamento del carico</h4>
              Il tracciamento del carico potrà avvenire in due modi:
              <ul>
                <li>Tracciamento persistente</li>
                <li>Tracciamento non persistente</li>
              </ul>

              Per avere una visione dello stato della hold anche in caso di
              crash del sistema è stato deciso di seguire il primo approccio, il
              quale porta a dover prendere un'ulteriore decisione su come
              gestire la persistenza, le alternative identificate sono:
              <ul>
                <li>Utilizzare un file json</li>
                <li>Utilizzare un database leggero (es. SQLite)</li>
              </ul>

              Data la semplicità della hold e la limitata quantità di dati da
              gestire si è optato per la prima soluzione in quanto non richiede
              la creazione di nuovi componenti e risulta più semplice da
              implementare. Inoltre la gestione della persistenza tramite file
              json locale permette, in caso di necessità, anche agli altri
              attori del sistema di accedere facilmente alle informazioni
              riguardanti lo stato della hold. All'avvio del sistema
              l'holdmanager verificherà se il file esiste e in caso positivo
              caricherà lo stato della hold dalla memoria, in caso contrario si
              occuperà di creare il file ed inizializzarlo. Per avere una
              visione d'insieme del sistema nel file JSON verranno memorizzati 3
              array, in cui ogni elemento corrisponde ad uno slot della hold:
              <ul>
                <li>
                  pids : se il valore è 0 lo slot è libero, se maggiore di zero
                  lo slot è occupato e il valore associato corrisponderà al PID
                  del prodotto caricato in quello slot
                </li>
                <li>
                  names: ogni elemento contiene il nome del prodotto caricato
                  nello slot associato o una stringa vuota se lo slot è libero
                </li>
                <li>
                  weights : ogni elemento corrisponde al peso del prodotto
                  caricato nello slot associato, se il valore è 0 lo slot è
                  libero. La somma di questi valori permetterà di ottenere il
                  peso attuale della hold
                </li>
              </ul>
              Oltre a questi array nel file JSON verrà memorizzato anche
              <i>MAXLOAD</i>, cioè il peso massimo che la hold può sostenere
              <br />
              Il file JSON avrà dunque la seguente struttura:
              <pre>
  {
    "pids": [0, 0, 0, 0],
    "names": ["", "", "", ""],
    "weights": [0, 0, 0, 0],
    "MAXLOAD": 100
  }
              </pre>
            </div>
          </div>
        </div>
      </div>

      <h2>Test plans</h2>
      <div class="remark">
        <div class="textbody">
          Lo scopo della fase di test è quello di verificare il funzionamento
          del core business, cioè dei componenti
          <strong> cargoservice </strong>, <strong> productservice</strong> e
          <strong> cargorobot </strong>.

          <div class="textbody">
            <table class="test-plan-table">
              <thead>
                <tr>
                  <th>Test</th>
                  <th>Attori</th>
                  <th>Servizi</th>
                  <th>Descrizione</th>
                  <th>Modello</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Evento di richiesta caricamento</td>
                  <td>mockuser; cargoservice;</td>
                  <td></td>
                  <td>
                    Il QActor tester, simulando il mockuser, invia una richiesta
                    di caricamento contenente il PID del prodotto al
                    cargoservice
                  </td>
                  <td>test_interactions.qak<br />CargoSystemTest.java</td>
                </tr>
                <tr>
                  <td>Verifica prodotto registrato e peso</td>
                  <td>cargoservice; holdManager;</td>
                  <td>productService;</td>
                  <td>
                    Il cargoservice invia il PID ricevuto a holdManager che
                    controlla, interrogando il productService, che il prodotto
                    sia registrato e che il peso non superi il limite imposto
                    dai vincoli. Invia un messaggio contenente lo slot in cui
                    mettere il prodotto o un messaggio di errore a cargoservice.
                  </td>
                  <td>test_interactions.qak<br />CargoSystemTest.java</td>
                </tr>
                <tr>
                  <td>Arrivo di un carico</td>
                  <td>mockuser; cargoservice; cargoRobot</td>
                  <td></td>
                  <td>
                    Il QActor tester, simulando il mockuser, invia un messaggio
                    a cargoservice quando rileva la presenza di un pacco
                    contenente lo slot in cui depositare il pacco.
                  </td>
                  <td>test_interactions.qak<br />CargoSystemTest.java</td>
                </tr>
                <tr>
                  <td>Avvio del cargoRobot</td>
                  <td>cargoservice; cargoRobot;</td>
                  <td>basicRobot</td>
                  <td>
                    Il cargoservice invia al cargoRobot un messaggio contenente
                    lo slot a cui andare/ le coordinate dello slot a cui andare.
                    Quest'ultimo pilota il basicRobot.
                  </td>
                  <td>test_interactions.qak<br />CargoSystemTest.java</td>
                </tr>
                <tr>
                  <td>Fine caricamento</td>
                  <td>cargoRobot; cargoservice</td>
                  <td>basicRobot</td>
                  <td>
                    Il cargoRobot pilota il basicRobot fino alla HOME, manda un
                    segnale a cargoservice che si rimette in ascolto di nuove
                    richieste di carico.
                  </td>
                  <td><br /></td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <h2>Project</h2>
      <div class="remark">
        <div class="textparagraph">
          <h3>Rappresentazione della hold</h3>
          <div class="textbody">
            Il robot rappresenta internamente la hold come un piano cartesiano.
            Questa viene quindi suddivisa in una griglia dove ciascuna cella è
            un quadrato avente lato pari alla dimensione del basicrobot, così da
            poter formalizzare il concetto di posizione, intesa come una coppia
            di coordinate cartesiane. La home si troverà nel punto di origine,
            quindi alle coordinate (0,0) mentre i vari slot sono visibili
            nell'immagine seguente, che è analoga alla configurazione già
            presente all'interno del robot fornito dal committente e per questo
            non è modificabile.
            <br />
            <div class="text-center">
              <img src="resources/map.png" alt="grid" width="25%" />
            </div>
            In particolare si avranno:
            <ul>
              <li>Home alle coordinate (0,0)</li>
              <li>Slot 1 alle coordinate (2,1)</li>
              <li>Slot 2 alle coordinate (3,1)</li>
              <li>Slot 3 alle coordinate (2,3)</li>
              <li>Slot 4 alle coordinate (3,3)</li>
              <li>Slot 5 alle coordinate (4,2)</li>
              <li>
                Come scelta progettuale, non essendo specificata nella mappa
                data dal committente, è stato deciso di posizionare la IOPort
                alle coordinate (1,5)
              </li>
            </ul>
          </div>
        </div>

        <div class="textparagraph">
          <h3>comportamento del cargoservice</h3>
          <div class="textbody">
            Il cargoservice è l'attore che ha il compito di controllare il
            funzionamento del sistema e coordinare le comunicazioni tra i
            diversi componenti. Al momento della ricezione di una richiesta di
            caricamento da parte dell'utente, contenente il PID del prodotto che
            intende depositare, verrà inviata all'<strong>holdmanager</strong>
            una richiesta <i>controlproduct(pid)</i>, rimanendo dunque in attesa
            di una risposta corrispondente all'esito,
            <i>productaccepted(slot)</i> o <i>productrejected()</i> conseguenti
            ai controlli di cui è responsabile <strong>holdmanager</strong>. Al
            momento della ricezione della risposta comunicherà all'utente
            l'esito e, se sarà positivo, inizialmente scatenerà un evento (utile
            per l'interazione con i componenti non ancora definiti in questa
            fase) e successivamente rimarrà in attesa del segnale di carico
            proveniente dal sonar. In caso contrario tornerà nello stato di
            attesa delle richieste di carico. Al momento della ricezione del
            segnale dal sonar comunicherà al <strong>cargorobot</strong> tramite
            richiesta <i>load(slot)</i> lo slot precedentemente indicato
            dall'<strong>holdmanager</strong> in cui andare a depositare il
            prodotto. Successivamente attenderà il completamento delle
            operazioni del <strong>cargorobot</strong>, il quale risponderà con
            <i>loadended()</i> in caso di successo o <i>loadfailed()</i> in caso
            di errore, prima di tornare in attesa di una nuova richiesta di
            carico. <br />

            Oltre al suo normale flusso di esecuzione, il cargoservice dovrà
            gestire i segnali di interruzione provenienti dal sonar in caso di
            malfunzionamento, così da andare a sospendere le attività di tutti i
            componenti del sistema fino al rientro dell'errore
          </div>
        </div>

        <div class="textparagraph">
          <h3>comportamento del cargorobot</h3>
          <div class="textbody">
            Al momento della ricezione della richiesta <i>load(slot)</i> da
            parte del cargoservice, il cargorobot si occuperà di inviare le
            istruzioni di spostamento al basicrobot. In particolare vengono
            identificate 3 fasi di movimento principali, le quali verranno
            eseguite in sequenza:
            <ul>
              <li>Spostamento dalla posizione corrente alla ioport</li>
              <li>Spostamento dalla ioport allo slot specificato</li>
              <li>Spostamento dallo slot alla home</li>
            </ul>

            Le coordinate delle diverse destinazioni verranno recuperate da una
            base di conoscenza prolog. Nella base di conoscenza sono definiti
            dei predicati del tipo:
            <i>position(X, Y, DIR, P).</i>
            che associano a ciascun punto della mappa (come slot, home, ioport)
            le coordinate assolute (X, Y) e la direzione DIR. Il predicato di
            accesso:
            <i>getPoint(P, X, Y, DIR) :- position(X, Y, DIR, P).</i>
            consente al cargorobot di ottenere le coordinate e la direzione
            relative a una determinata posizione P.
            <ul>
              <li>x: ascissa del punto</li>
              <li>y: ordinata del punto</li>
              <li>
                direzione: permetterà di ruotare il robot verso la posizione
                rilevante di interesse
              </li>
            </ul>
          </div>
        </div>

        <div class="textparagraph">
          <h3>comportamento di holdmanager</h3>
          <div class="textbody">
            Al momento della ricezione della richiesta
            <i>controlproduct(pid)</i> da parte del cargoservice, holdmanager si
            occuperà di gestire il controllo del prodotto relazionandosi
            direttamente con <strong>productservice</strong>. Al momento della
            ricezione di una richiesta <i>controlproduct(pid)</i> proveniente
            dal cargoservice invierà una richiesta <i>getProduct(pid)</i> a
            <strong>productservice</strong> per recuperare le informazioni
            riguardanti il prodotto specificato. In base al payload della
            risposta <i>getProductAnswer(JSonString)</i> holdmanager otterrà i
            dati del prodotto in formato JSON e se il PID risulterà essere
            maggiore di 0 (prodotto registrato) verificherà se il peso del
            prodotto è adeguato alla capacità massima della stiva e deciderà a
            che slot assegnare il carico (se sono presenti slot liberi). Infine,
            in caso i controlli abbiano avuto esito positivo, invierà una
            risposta al cargoservice con il messaggio
            <i>productaccepted(slot)</i> specificando lo slot scelto, in caso
            contrario verrà inviata una risposta di rifiuto
            <i>productrejected()</i>. Nel momento in cui terminerà il
            caricamento del prodotto, holdmanager aggiornerà il file JSON
            utilizzato per tracciare lo stato della hold
          </div>
        </div>
      </div>

      <h2>System Design</h2>
      <div class="medium-12 text-center remark">
        <img
          src="../sprint1_system_overviewarch.png"
          class="text-center"
          alt="map"
          width="100%"
        />
      </div>

      <footer class="footer">
        <div class="grid-container fluid">
          <div class="grid-x grid-margin-x align-middle">
            <div class="small-12 medium-3 text-center">
              <a
                class="button change"
                href="../../Sprint0/userDocs/sprint0_v2.html"
              >
                &larr; Previous Sprint
              </a>
            </div>

            <div class="small-12 medium-4 text-center">
              Fasano Andrea : andrea.fasano3@studio.unibo.it <br />
              <!-- 0001189592 -->
              Florian Alberto : alberto.florian@studio.unibo.it <br />
              <!-- 0001189572 -->
              Sampaoli Giacomo : giacomo.sampaoli@studio.unibo.it
              <!-- 0001176431 -->
            </div>

            <div class="small-12 medium-2 align-middle text-center">
              <a
                href="https://github.com/FlorAber/ISS25-cargoservice"
                class="button primary"
                target="_blank"
              >
                GitHub Repository
              </a>
            </div>

            <div class="small-12 medium-3 text-right">
              <a class="button change disabled"> Next Sprint &rarr; </a>
            </div>
          </div>
        </div>
      </footer>
    </div>
  </body>
</html>
