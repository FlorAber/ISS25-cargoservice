System sprint1_system_overview

// MESSAGGI DI AVVIO DEL SISTEMA IL CARGOMANAGER PARTE DOPO AVERLI RICEVUTI ENTRAMBI INVIANDOSI UN allRady
Dispatch robotready : robotready(0)
Dispatch databaseready : databaseready(0)

Dispatch allready : allReady(0)

// MOCK
//Request createProduct : product(JSonString) // mock to productservice - DA USARE PER CARICARE PRODOTTI NEL DB, SOLO PRIMO AVVIO

// Load request, starting point of the whole scenary
Request loadrequest: loadrequest(PID)				 // mock to cargomanager
Reply loadaccepted : loadaccepted(X) for loadrequest // cargomanager to mock
Reply loadrejected : loadrejected(X) for loadrequest // cargomanager to mock

// Check product existance in hold manager
Request controlproduct : controlproduct(PID)  						// cargomanager to hold manager
Reply productaccepted : productaccepted(SLOT) for controlproduct	// hold manager to cargomanager 
Reply productrejected : productrejected(MSG)  for controlproduct	// hold manager to cargomanager

// Sonar detects the product 
Dispatch doDeposit : doDeposit(X)  // mock to cargomanager

// TEMPORANEA PER GESTIRE LA FINE DEL CARICAMENTO E AGGIORNARE LO STATO INTERNO DELL'HOLDMANAGER, SOSTITUIBILE CON ALTRO
Event productloaded : productloaded(X) 

//cargomanager to cargorobot
Request load : load(SLOT)

Reply loadended : loadended(0) 		for load
Reply loadfailed : productRejecteded(MSG)  for load

// BASIC ROBOT CONTROLS
Request engage        : engage(OWNER,STEPTIME)	
Reply   engagedone    : engagedone(ARG) for engage 
Reply   engagerefused : engagerefused(ARG) for engage 

Request moverobot    :  moverobot(TARGETX, TARGETY)
Reply moverobotdone  :  moverobotdone(ARG) for moverobot
Reply moverobotfailed:  moverobotfailed(PLANDONE, PLANTODO) for moverobot

Dispatch setdirection : dir( D )
Dispatch setrobotstate: setpos(X,Y,D)

Event alarm : alarm(ARG) 

//Dispatch disengage    : disengage(ARG)
 
//holdmanager to productservice
Request getProduct 		 : product(ID)
Reply 	getProductAnswer : product(JSONSTRING) for getProduct // formato di messaggio coerente con product service
												
//Sonar
Event sonaralert : sonaralert(X)	 // inizia stato di alert	
Event sonarok    : sonarok(X)		 // terminato stato di alert

Event stopthesystem:stopthesystem(X) 		// Evento interno per fermare gli altri attori
Event resumethesystem:resumethesystem(X)	// Evento interno per far ripartire gli altri attori

// ------------------------------------------------------------------------
// CONTEXTS AND EXTERNAL QACTORS
// ------------------------------------------------------------------------

Context ctx_cargo  ip  [host="localhost" port=8014]

Context ctx_basicrobot  ip  [host="127.0.0.1" port=8020]
Context ctx_productservice ip [ host="127.0.0.1" port=8111]

ExternalQActor productservice context ctx_productservice
ExternalQActor basicrobot context ctx_basicrobot

QActor cargomanager context ctx_cargo { 
	
	[#
		var robotReady: Boolean = false
		var databaseReady: Boolean = false
		
		var PID: Int = 0
		var SLOT_TO_LOAD: Int = -1
		
		var currentState: String = ""
		var hasPendingLoad: Boolean = false
	#]
	
	State s0 initial{
		delay 250   
		println("$name : starting") color green  	
	}
	Goto waitForTheOthers
	
	State waitForTheOthers {
//		println("$name : waiting for other services") color green  
		if [# robotReady && databaseReady #] {
			autodispatch allready : allready(0)
		}
	}
	Transition t
		whenMsg robotready -> robotReady
		whenMsg databaseready -> databaseReady
		whenMsg allready -> wait
		
	State robotReady {
		println("$name : robotmanager ready") color green  
		[# robotReady = true #]
	} Goto waitForTheOthers
	
	State databaseReady {
		println("$name : productservice ready") color green  
		[# databaseReady = true #]
	} Goto waitForTheOthers
	
	// ------------------------------------------------------------------------
	// QUI COMINCIA LA VERA LOGICA DEL CARGOMANAGER
	// ------------------------------------------------------------------------
	
	State wait{
		[# currentState = "wait" #]
		println ("$name : waiting for requests...")	color green
		
	}
	Transition t
		whenRequest loadrequest -> checkLoadRequest
		whenInterruptEvent sonaralert -> handleAlert
		
	// Controlla con il productservice se il prodotto è registrato e si fa dare uno slot
	State checkLoadRequest { //asking holdmanager for pid
		onMsg ( loadrequest : loadrequest(PID) ){
			[# 
				PID = payloadArg(0).toInt();
			#]
			println("$name : Asking for pid: $PID") color green 
			request holdmanager -m controlproduct : controlproduct($PID)
		}
	}
	Transition t
		whenReply productaccepted -> productAccepted
		whenReply productrejected -> productRejected
		
	// Prodotto rifiutato dal productservice
	State productRejected {
		onMsg (productrejected: productrejected(ERRORPAYLOAD)){
			[# val ERRORPAYLOAD = payloadArg(0) #]
			println("$name : received error $ERRORPAYLOAD") color green
			replyTo loadrequest with loadrejected : loadrejected($ERRORPAYLOAD)
		}
	}
	Goto wait
		
	// Prodotto accettato dal productservice
	State productAccepted{
		onMsg (productaccepted: productaccepted(SLOT_TO_LOAD)){
			[#  SLOT_TO_LOAD=payloadArg(0).toInt()  #]
			println ("$name : product $PID accepted and assigned to slot $SLOT_TO_LOAD") color green
			replyTo loadrequest with loadaccepted : loadaccepted($PID)
		}
	}
	Goto waitForDeposit
	
	// Attende segnale di deposito dal sonar
	State waitForDeposit {
		[# currentState = "waitForDeposit" #]
		println ("$name : waiting for sonar deposit signal") color green
	}
	Transition t
		whenMsg doDeposit -> doDeposit
		whenInterruptEvent sonaralert -> handleAlert
	
	// Ricevuta richiesta di deposito
	State doDeposit{
		[# currentState = "doDeposit" #]
		println ("$name : package detected, proceeding with the loading") color green
		request cargorobot -m load : load($SLOT_TO_LOAD)
	} 
	Transition t
		whenEvent productloaded -> loadEnded
		whenInterruptEvent sonaralert -> handleAlert
		
	// Caricamento terminato, reset parametri
	State loadEnded {
		println ("$name : loading process ended") color green
		[#  		
			PID = 0;
			SLOT_TO_LOAD = -1;
		#]
	} 
	Goto wait
	
	State handleAlert{
		println ("$name : sonar in alert state") color red
		emit stopthesystem : stopthesystem(0)
	}
	Transition t
		whenEvent sonarok -> resumeOperations

	State resumeOperations {
		println ("$name : sonar exited from alert state") color red
		emit resumethesystem : resumethesystem(0)
		returnFromInterrupt
	}
}

QActor cargorobot context ctx_cargo { 
	
	[#
		data class Position(val x: Int, val y: Int, val direction: String)

		val home = Position(0,0,"down")
		val ioport = Position(1,4,"up")

		val slots = arrayOf(
		    Position(1, 1, "left"),
		    Position(4, 1, "right"),
		    Position(1, 3, "left"),
		    Position(4, 3, "right")
		)
		
		
		var moving: Boolean = false			//Indica se il robot si stava muovendo, necessario per ripartire dopo interrupt
		var destination = Position(0,0,"")	//Se moving a true, utilizzato per portare il robot alla stessa destinazione di quando è stato interrotto
		
		var TARGETSLOT = -1
		var currentState = -1 //Contiene un numero che indica lo stato in cui si trova, serve per ripartire dopo l'alert del sonar
	#]
	
	State s0 initial{
		delay 500   
		println("$name : starting") color yellow 
	} 
	Goto engage
	
	State engage {
		println("$name : engaging basicrobot") color yellow
		request basicrobot -m engage:engage($MyName,350)
	}
	Transition t
		whenReply engagedone -> wait
		whenReply engagerefused -> engage
		
	State wait {
		delay 500
		
		[# currentState = 0 #]
		
		onMsg(engagedone : engagedone(ARG) ) {
			[# var ARG = payloadArg(0) #]
			println("$name : robot engaged, response - $ARG") color yellow
			
			forward cargomanager -m robotready : robotready(0)
		}
		println("$name : waiting for movement requests") color yellow
	}
	Transition t
		whenRequest load -> movetoioport
		whenEvent stopthesystem -> systemStopped
		
	State movetoioport {
		delay 2000
		onMsg (load : load(SLOT)) {
			
			[#
				TARGETSLOT = payloadArg(0).toInt()
				val X = ioport.x
				val Y = ioport.y
				val D = ioport.direction
				
				moving = true
				destination = ioport
			#]
			
			println("$name : moving robot to slot IOPORT at Positions ($X,$Y)") color yellow
			request basicrobot -m moverobot:moverobot($X,$Y)
//			delay 500
//			forward basicrobot -m setdirection:dir($D)
		}
	}
	Transition t 
		whenReply moverobotdone -> movetoslot
		whenReply moverobotfailed -> movefailed
		whenInterruptEvent stopthesystem -> systemStopped
	
	State movetoslot {
		delay 2000
		onMsg ( moverobotdone : moverobotdone(ARG)) {
			[#
				val X = slots[TARGETSLOT].x
				val Y = slots[TARGETSLOT].y
				val D = slots[TARGETSLOT].direction
				
				moving = true
				destination = slots[TARGETSLOT]
			#]
			
			println("$name : moving robot to slot $TARGETSLOT at Positions ($X,$Y)") color yellow
			request basicrobot -m moverobot:moverobot($X,$Y)
//			delay 500
//			forward basicrobot -m setdirection:dir($D)
		}
	}
	Transition t
		whenReply moverobotdone -> movetohome
		whenReply moverobotfailed -> movefailed
		whenInterruptEvent stopthesystem -> systemStopped
	
	State movetohome {
		delay 2000
		onMsg ( moverobotdone : moverobotdone(ARG)) {
			[#
				val X = home.x
				val Y = home.y
				val D = home.direction
				
				moving = true
				destination = home
			#]
			
			println("$name : moving robot to slot HOME at Position ($X,$Y)") color yellow
			request basicrobot -m moverobot:moverobot($X,$Y)
//			delay 500
//			forward basicrobot -m setdirection:dir($D)
		}
	}
	Transition t
		whenReply moverobotdone -> ended
		whenReply moverobotfailed -> movefailed
		whenInterruptEvent stopthesystem -> systemStopped
	
	State ended {
		[# 
			moving = false
			TARGETSLOT = -1 
		#]
		emit productloaded :  productloaded($TARGETSLOT)
	}
	Goto wait
	
	State systemStopped {
		println("$name : system forced to stop ") color red
		emit alarm : alarm(blokkabilly)
	}
	Transition t
		whenReply moverobotdone   -> robotStopped  // risposta ad alarm in caso di interruzione alla fine del movimento
   		whenReply moverobotfailed -> robotStopped  // risposta ad alarm in caso di interruzione durante il movimento
	
	State robotStopped {	
		println("$name : robot movement stopped") color red
	}
	Transition t
		whenEvent resumethesystem -> resumeRobot
		
	State resumeRobot {
		println("$name : robot movement resumed") color red
		if [# moving #] {
			[#
			  val X = destination.x
			  val Y = destination.y
			  val D = destination.direction
			#]
			request basicrobot -m moverobot:moverobot($X,$Y)
//			delay 500
//			forward basicrobot -m setdirection:dir($D)
		}

		returnFromInterrupt
	}
	
	State movefailed {
		onMsg ( moverobotfailed : moverobotfailed(PLANDONE, PLANTODO)) {
			[# 	
				val PLANDONE = payloadArg(0) 
				val PLANTODO = payloadArg(1)
			#]
			println("$name : robot movement ended with failure - done($PLANDONE) todo($PLANTODO)") color yellow
		}
	}
	
}

QActor holdmanager context ctx_cargo {
	
	import "kotlinx.serialization.*"
	import "kotlinx.serialization.json.*"
	import "java.io.File"
	
	[#
		// Used to serialize local variables and memorize them in the JSON file
		@Serializable
		data class HoldState(
		    val pids    : Array<Int>,
		    val names   : Array<String>,
		    val weights : Array<Int>,
		    val MAXLOAD : Int
		)
		
		fun saveState(state: HoldState, filename: String = "holdState.json") {
		    val json = Json { prettyPrint = true }
		    val jsonString = json.encodeToString(state)
		    File(filename).writeText(jsonString)
		}
		
		fun resetState(filename: String = "holdState.json") {
		    val state = HoldState(
		        pids = arrayOf(0, 0, 0, 0),
		        names = arrayOf("", "", "", ""),
		        weights = arrayOf(0, 0, 0, 0),
		        MAXLOAD = 100
		    )
		    saveState(state, filename)
		}
		
		fun loadState(filename: String = "holdState.json"): HoldState? {
		    val file = File(filename)
		    if (!file.exists()) return null
		    val json = Json { ignoreUnknownKeys = true }
		    return json.decodeFromString(file.readText())
		}
		
    	var pids = arrayOf(0, 0, 0, 0)			// Ogni elemento corrisponde ad uno slot, contiene i PID dei prodotti caricati
    	var names = arrayOf("", "", "", "")		// Ogni elemento corrisponde ad uno slot, contiene i nomi dei prodotti caricati
    	var weights = arrayOf(0, 0, 0, 0)		// Ogni elemento corrisponde ad uno slot, contiene i pesi dei prodotti caricati
    	val MAXLOAD = 100						// Carico massimo della hold
    	
    	var waitingProduct: JSONObject? = null	// Oggetto JSON che rappresenta il prodotto in attesa di essere caricato, terminato il robot viene registrato nello stato
	#]
	
	
	State start initial {
		delay 750  
		println("$name : starting") color blue 
		
		[# val loaded = loadState() #]
		if [# loaded != null #] {
			println("$name : state file found, loading previous state ") color blue 
			[#
				pids = loaded.pids
				names = loaded.names
				weights = loaded.weights
				
			#]
		} else {
			println("$name : state file not found, initializing") color blue 
			[# resetState() #]
		}
		
		forward cargomanager -m databaseready : databaseready(0)
	}
	Goto wait
	
	
	State wait {
		println("$name : waiting for requests") color blue 
	}
	Transition t 
		whenRequest controlproduct -> handleControlRequest
		
	// Invia richiesta al productservice
	State handleControlRequest {
		onMsg( controlproduct : controlproduct(PID) ) {
			[# val PID = payloadArg(0).toInt() #]
			println("$name : received control request for PID : $PID") color blue 
			request productservice -m getProduct : product($PID)
		}
	}
	Transition t
		whenReply getProductAnswer -> checkProductAnswer
	
	// Controlla la risposta del productservice e se positiva controlla se il prodotto può essere inserito nella hold
	State checkProductAnswer {
		onMsg ( getProductAnswer : product(JsonString) ) {
			[# 				
				val parser = JSONParser()
				val jsonString = payloadArg(0).toString()
				val jsonObj = parser.parse(jsonString) as JSONObject
				
				val pid = (jsonObj["productId"] as Long).toInt()
				val weight = (jsonObj["weight"] as Long).toInt()

				var rejected = false
				var ERMSG = ""	
				var SLOT = 0		
				
				if( pid > 0 ) {														// Prodotto registrato
					if ( MAXLOAD >= (weights.sumOf {it} + weight)) {				// Capienza stiva sufficiente
						SLOT = pids.indexOfFirst { it == 0 }
						if(SLOT < 0) {											    // Nessuno slot libero
							rejected = true
							ERMSG = "Tutti_gli_slot_sono_gia_occupati"
						}
					} else {
						rejected = true
						ERMSG = "Capienza_stiva_non_sufficiente"
					}
				} else {
					rejected = true
					ERMSG = "Prodotto_non_registrato"
				}
				
			#]
			
			if [# rejected #] {
				println("$name : product rejected") color blue
				replyTo controlproduct with productrejected : productrejected($ERMSG)
			} else {
				println("$name : product accepted") color blue 
				[# waitingProduct = jsonObj #]
				replyTo controlproduct with productaccepted : productaccepted($SLOT)
			}
			
		}
	} 
	Transition t
		whenEvent productloaded -> updateHoldState
	
	// Aggiorna lo stato interno della stiva ed il contenuto del file JSON
	State updateHoldState {
		[# val waitingProd = waitingProduct #]
		if [# waitingProd != null #] {
			[#
				val pid = (waitingProd["productId"] as Long).toInt()
				val pname =  (waitingProd["name"] as String)
				val weight = (waitingProd["weight"] as Long).toInt()
			
				val slot = pids.indexOfFirst { it == 0 }
				
				pids[slot] = pid
				names[slot] = pname
				weights[slot] = weight
				
				val state = HoldState(pids, names, weights, MAXLOAD)
				
				saveState(state)				
			#]
			println("$name : updated hold state - $state") color blue 
		} else {
			println("$name : hold state not changed") color blue 
		}
	}
	Goto wait
}

QActor mockactor context ctx_cargo{
	
	[#
		var ERROR = false;
		var COUNTLOADS = 0
	#]
	
	State s0 initial{
		delay 3000
		println("$name : starting") color cyan 
//		// CODE NEEDED TO LOAD MONGODB AT THE FIRST BOOT OF THE SYSTEM 
//		println("$name : loading productservice db") color cyan 
//		[# 
//			val JsonObj1 = "'{\"productId\":1,\"name\":\"p1\",\"weight\":10}'" 
//			val JsonObj2 = "'{\"productId\":2,\"name\":\"p2\",\"weight\":20}'" 
//			val JsonObj3 = "'{\"productId\":3,\"name\":\"p3\",\"weight\":30}'" 
//			val JsonObj4 = "'{\"productId\":4,\"name\":\"p4\",\"weight\":40}'" 
//			val JsonObj5 = "'{\"productId\":5,\"name\":\"p5\",\"weight\":200}'" 
//		#]
//		request productservice -m createProduct : product($JsonObj1)
//		request productservice -m createProduct : product($JsonObj2)
//		request productservice -m createProduct : product($JsonObj3)
//		request productservice -m createProduct : product($JsonObj4)
//		request productservice -m createProduct : product($JsonObj5)

	} 
	Goto load_test
	
	State load_test{
		
		[# COUNTLOADS++ #]
		delay 5000
		if[# COUNTLOADS < 5 #] {
			println("$name : richiesta! ") color cyan
			request cargomanager -m loadrequest : loadrequest($COUNTLOADS)
		}	
	}
	Transition t
		whenReply loadaccepted -> deposit
		whenReply loadrejected -> loadFail
		
	State deposit {
		println("$name : PID found, proceeding to do Deposit") color cyan
		forward cargomanager -m doDeposit : doDeposit(1)
		
		if [# COUNTLOADS == 2 || COUNTLOADS == 4 #] {
			delay 3000
			emit sonaralert : sonaralert(0)
			
			delay 3000
			emit sonarok : sonarok(0)
		}

	}
	Goto load_test 			// Da usare per provare ad inviare tante load in cascata
//	Transition t
//		whenEvent productloaded -> end //controllo su evento in caso di robot che termina il suo lavoro -> end
	
	State loadFail{
		[# ERROR = true #]
		onMsg (loadrejected : loadrejected(ERRORPAYLOAD)) {
			[# val ERRORPAYLOAD = payloadArg(0)#]
			println("$ERRORPAYLOAD") color red
		}
		println("PID not found") color red
	}
	
	State end {
		if [# ERROR == true #]{
			println("$name : Failed") color cyan
		} else{
			println("$name : Success") color cyan
		}
	}
	Goto load_test
}