<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="it">
  <head>
    <!-- <script type="text/javascript" src="../css/issStyle.js"></script> -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"
      crossorigin="anonymous"
    ></script>
    <link rel="stylesheet" type="text/css" href="../../resources/_styles/style.css" />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <title>ISS25 - Sprint 0</title>
  </head>

  <body>
    <div id="top">
      <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE - Sprint 0</h1>
    </div>
    <div class="body">
      <h2>Introduction</h2>
      <div class="remark">
        <div class="textbody">
          Lo scopo del team è quello realizzare un sistema software sulla base
          dei requisiti forniti dal cliente e presentanti nel
          <a href="../../resources/TemaFinale25.html"> tema finale 2025</a>.
          <br/>
          L'obiettivo dello Sprint 0 è di analizzare i requisiti forniti dal
          cliente, comprenderli pienamente e costruire un modello di riferimento
          del sistema che formalizzi i requisiti.
        </div>
      </div>

      <h2>Requirements</h2>

      <div class="remark">
        <a
          href="../../resources/TemaFinale25.html"
          class="button primary"
          target="_blank"
        >
          Client requirements
        </a>
      </div>

      <h2>Requirement analysis</h2>

      <div class="remark">
        A partire dai requisiti forniti dal cliente, si possono individuare diversi componenti del sistema:

        <div class="textparagraph">
            <h3>cargoservice</h3>
            <div class="textbody">
                Sistema software che si occupa della gestione della nave cargo.
                È in grado di ricevere richieste di caricamento di prodotti tramite l'invio di un messaggio contenente il PID del prodotto da caricare e si occupa di coordinare tutte
                le operazioni all'interno del sistema <br/>
                Ad oggi non è possibile definire le caratteristiche della GUI non essendo specificati abbastanza requisiti. <br/>
                Alla richiesta di caricamento di un prodotto da parte dell'utente, 
                il cargoservice potrà rispondere con un messaggio <i>loadaccepted()</i> in caso 
                sia possibile procedere al carico del prodotto, o con un messaggio <i>loadrejected(ERRPAYLOAD)</i> che specifica le motivazioni per cui il caricamento non può essere effettuato, che possono essere:
                <ul>
                    <li> Prodotto non registrato nel database </li>
                    <li> Peso totale della hold superiore ad un limite massimo (maxLoad)</li>
                    <li> Hold piena, non ci sono slot liberi a cui caricare il prodotto </li>
                </ul>
            </div>
        </div>

        <!-- <div class="textparagraph">
          <h3>productservice</h3>
          <div class="textbody">
            Servizio fornito dal committente che verrà integrato all'interno del sistema e si occupa della gestione del database di prodotti.
            È costituito da un'entità con la quale è possibile comunicare tramite l'invio di messaggi, in particolare per richiedere informazioni sui prodotti è
            possibile inviare un messaggio contenente il PID del prodotto di interesse e si riceverà in risposta un messaggio contenente le informazioni richieste, se il prodotto è registrato, 
            o un messaggio di errore in caso contrario.
          </div>
        </div> -->

        <div class="textparagraph">
          <h3>sensor</h3>
          <div class="textbody">
            Sottosistema incaricato della gestione di due dispositivi fisici forniti dal cliente: un led e un sonar.
            Per questo sarà costituito da un RaspBerryPi. Ad oggi non sono state ancora definite ulteriori specifiche
          </div>
        </div>

        <div class="textparagraph">
          <h3>cargorobot</h3>
          <div class="textbody">
             <!-- Il cargorobot è un componente incaricato di controllare un Differential Drive Robot fornito dal committente chiamato basicrobot, la cui documentazione è visibile al seguente
            <a href="../../resources/BasicRobot24.html">link</a>.
            Essendo il basicrobot controllabile tramite l'invio di messaggi il cargorobot non potrà essere espresso come un semplice POJO ma sarà necessario modellarlo come componente attivo.
            L'attivazione del cargorobt dovrà avvenire tramite l'invio di messaggi provenienti dal cargoservice.
            -->
            Da requisiti evinciamo che questo componente avrà il compito di occuparsi del caricamento
            dei container all'interno della hold.
            Per fare ciò dovrà essere in grado di:
            <ul>
                <li> Muoversi liberamente all'interno della hold </li>
                <li> Caricare i container che vengono consegnati alla posizione della I/O Port e posizionarli negli slot di carico disponibili</li>
            </ul>

            Il primo punto richiede che il cargorobot sia in grado di muoversi all'interno della hold,
            evitando ostacoli e rispettando i vincoli fisici dell'ambiente. 
            
            <br>
            In merito il committente ha fornito un ambiente virtuale <a href="../../resources/VirtualRobot23.html">WEnv</a> che simula un Differential Drive Robot e ha già al suo interno
            la rappresentazione virtuale della stiva della nave richiesta dal committente. 
            
            <br>
            Viene inoltre fornito <a href="../../resources/BasicRobot24.html">basicrobot</a>, un componente software che permette di controllare il DDR virtuale contenuto all'interno di WEnv tramite l'invio di messaggi,
            si tratta di un'entità attiva a stati finiti, in grado di cambiare stato a seconda 
            dei messaggi che riceve o autonomamente, definiamo dunque il basicrobot come un attore.
            basicrobot permette di effettuare singole mosse con il DDR o sequenze di mosse, a seconda del messaggio di
            richiesta.
            <br>
            Siamo inoltre a conoscenza del fatto che il basicrobot incorpora un <strong>planner</strong>,
            un componente software che si occupa di calcolare il percorso ottimale per raggiungere una destinazione a partire dalla posizione attuale del robot.

            <br>
            <br><br>
            Di seguito sono riportati i messaggi con cui è possibile interfacciarsi con il basicrobot:

            <br><br><br>
            <pre style="width: 80%; padding: 1px; border: 5px solid #ccc; border-radius: 5px; overflow: auto;"><code>
Dispatch cmd       	: cmd(MOVE)         
Dispatch end       	: end(ARG)         
    
Request step       : step(TIME)	
Reply stepdone     : stepdone(V)                 for step
Reply stepfailed   : stepfailed(DURATION, CAUSE) for step

Event  sonardata   : sonar( DISTANCE ) 	   
Event obstacle     : obstacle(X) 
Event info         : info(X)    

Request  doplan     : doplan( PATH, STEPTIME )
Reply doplandone    : doplandone( ARG )    for doplan
Reply doplanfailed  : doplanfailed( ARG )  for doplan

Dispatch setrobotstate: setpos(X,Y,D) //D =up|down!left|right

Request engage        : engage(OWNER, STEPTIME)	
Reply   engagedone    : engagedone(ARG)    for engage
Reply   engagerefused : engagerefused(ARG) for engage

Dispatch disengage    : disengage(ARG)

Request checkowner    : checkowner(CALLER)
Reply checkownerok    : checkownerok(ARG)      for checkowner
Reply checkownerfailed: checkownerfailed(ARG)  for checkowner
    
Event alarm           : alarm(X)
Dispatch nextmove     : nextmove(M)
Dispatch nomoremove   : nomoremove(M)
    
Dispatch setdirection : dir( D )  //D =up|down!left|right

//Inglobamento endosimbitico di robotpos
Request moverobot    :  moverobot(TARGETX, TARGETY)  
Reply moverobotdone  :  moverobotok(ARG)                    for moverobot
Reply moverobotfailed:  moverobotfailed(PLANDONE, PLANTODO) for moverobot
    
//Richieste di info 
Request getrobotstate : getrobotstate(ARG)
Reply robotstate      : robotstate(POS,DIR)  for getrobotstate

Request getenvmap     : getenvmap(X)
Reply   envmap        : envmap(MAP)  for getenvmap
</code></pre>
<br>
<br>

          </div>
        </div>

        <div class="textparagraph">
          <h3>hold</h3>
          <div class="textbody">
            La hold rappresenta l'ambiente in cui il robot si muove. È formata
            da una stanza rettangolare nella quale sono presenti 5 slot di
            carico e una porta di I/O da cui entrano i container. Il robot
            quando fermo si trova nella posizione HOME e occupa una porzione di spazio pari
            alle sue dimensioni. <br/>
            La stiva della nave può dunque essere rappresentata come una griglia bidimensionale 
            dove ogni punto ha coordinate discrete misurate in termini di dimensioni del robot. 
            La dimensione del robot sarà l'unità di misura principale per gli spostamenti. <br />
            
            Lo stato di questo componente verrà aggiornato durante la normale esecuzione del sistema
            e verra visualizzato tramite la GUI, componente di cui al momento non si hanno sufficienti
            informazioni per compiere un'analisi dei requisiti dettagliata.

            <div class="medium-12 text-center margin-5">
              <img src="./resources/map.png" class="" alt="map" width="25%" />
            </div>
          </div>
        </div>
      </div>

      <h2>Model</h2>
      <div class="remark">
        Poichè si è osservato che il sistema richiesto dal cliente è un sistema costituito da un insieme di componenti attivi che comunicano tra loro tramite scambio di messaggi,
        questo risulta essere distante dalle tecnologie implementative tradizionali. 
        Per costruire un modello infatti è necessario utilizzare un linguaggio formale per la rappresentazione di sistemi distribuiti, in quanto strumenti tradizionali come ad esempio UML, 
        presentano un abstraction gap non trascurabile, permettendo di rappresentare solamente comunicazioni tra i componenti basate su procedure-call.
        Per questo motivo è stato deciso di utilizzare il linguaggio QAK, un Domain Specific Language che permette di modellare sistemi distribuiti basati su componenti attivi, chiamati attori, che interagiscono tramite scambio di messaggi. 
        QAK costituisce un linguaggio formale, ed è per questo comprensibile anche alla macchina, e per questo risulta essere un valido strumento per la formalizzazione dei requsiti con un linguaggio non ambiguo. 
      </div>

      <h2>Logical Model</h2>
      <div class="medium-12 text-center remark">
        <img
          src="../sprint0_system_overviewarch.png"
          class="text-center"
          alt="map"
          width="25%"
        />
      </div>

      <h2>Test plans</h2>
      <div class="remark">
        <div class="textbody">
         Il piano di test che è possibile stilare in questa fase del progetto è relativo
         al verificare che il corebusiness risponda alle richieste di carico con i messaggi
         attesi, <i>loadaccepted()</i> o <i>loadrejected(ERRPAYLOAD)</i>.
<pre style="width: 80%; padding: 1px; border: 5px solid #ccc; border-radius: 5px; overflow: auto;"><code>
// Test load request accepted
  @Test
    public void testLoadRequestAccepted() throws Exception {
        //Costruzione di richiesta con PID valido.

        String load_req = CommUtils.buildRequest("tester",
                "load_product", "load_product(1)", 
                "cargoservice").toString();
        
        System.out.println("Richiesta: " + load_req);
        
        //Risposta accettata perchè peso legato al PID inferiore di MaxLoad 
        String response = conn.request(load_req);
        
        System.out.println("Risposta: " + response); // Risposta contenente lo slot libero dove posizionare il container
        
        //Verifica che sia stata accettata
        assertTrue("TEST: richiesta accettata", 
                 response.contains("load_accepted"));
    }



// Test load request rejected weight exceeded
    @Test
    public void testLoadRequestRejectedWeightExceeded() throws Exception {
        //Costruzione di richiesta con PID non valido.

        String load_req = CommUtils.buildRequest("tester",
                "load_product", "load_product(5)", 
                "cargoservice").toString();
        
        System.out.println("Richiesta: " + load_req);
        
        //Risposta rifiutata perchè PID non registrato
        String response = conn.request(load_req);
        
        System.out.println("Risposta: " + response); // Risposta contenente l'errore
        
        //Verifica che sia stata rifiutata
        assertTrue("TEST: richiesta rifiutata", 
                 response.contains("load_rejected")
                 && response.contains("overweight"));
    }


// Test load request rejected no slot available
    @Test
    public void testLoadRequestRejectedNoSlot() throws Exception {
        //Costruzione di richiesta con PID non valido.

        String load_req = CommUtils.buildRequest("tester",
                "load_product", "load_product(6)", 
                "cargoservice").toString();
        
        System.out.println("Richiesta: " + load_req);
        
        //Risposta rifiutata perchè PID non registrato
        String response = conn.request(load_req);
        
        System.out.println("Risposta: " + response); // Risposta contenente l'errore
        
        //Verifica che sia stata rifiutata
        assertTrue("TEST: richiesta rifiutata", 
                 response.contains("load_rejected")
                 && response.contains("noslotavailable"));
    }

// Test load request rejected PID not registered
    @Test
    public void testLoadRequestRejectedPIDNotRegistered() throws Exception {
        //Costruzione di richiesta con PID non valido.

        String load_req = CommUtils.buildRequest("tester",
                "load_product", "load_product(999)", 
                "cargoservice").toString();
        
        System.out.println("Richiesta: " + load_req);
        
        //Risposta rifiutata perchè PID non registrato
        String response = conn.request(load_req);
        
        System.out.println("Risposta: " + response); // Risposta contenente l'errore
        
        //Verifica che sia stata rifiutata
        assertTrue("TEST: richiesta rifiutata", 
                 response.contains("load_rejected")
                 && response.contains("pidnotregistered"));
    }

</code></pre>
<br>
<br>
         
        </div>
      </div>

      <h2>Work plans</h2>
      <div class="remark">
        <div class="textbody">
          Il progetto verrà sviluppato in 3 sprint, secondo un ordine di
          priorità delle funzionalità:
          <ol>
            <li>
              Sprint 1 - Core Business : si svilupperà un modello che realizzi le funzionalità principali del sistema, tra cui il movimento del basicrobot. Tempo di sviluppo stimato 50 ore uomo.
            </li>
            <li>Sprint 2 - Sensor :  si realizzerà la parte del sistema che si occupa della gestione di led e sonar. Tempo di sviluppo stimato 40 ore uomo. </li>
            <li>Sprint 3 - GUI : si realizzerà l'interfaccia grafica che permetterà di visualizzare lo stato del sistema. Tempo di sviluppo stimato 20 ore uomo. </li>
          </ol>
      </div>

      <footer class="footer">
        <div class="grid-container fluid">
          <div class="grid-x grid-margin-x align-middle">
            <div class="small-12 medium-3 text-center">
              <a class="button change disabled"> &larr; Previous Sprint </a>
            </div>

            <div class="small-12 medium-4 text-center">
              Fasano Andrea : andrea.fasano3@studio.unibo.it <br />
              <!-- 0001189592 -->
              Florian Alberto : alberto.florian@studio.unibo.it <br />
              <!-- 0001189572 -->
              Sampaoli Giacomo : giacomo.sampaoli@studio.unibo.it
              <!-- 0001176431 -->
            </div>

            <div class="small-12 medium-2 align-middle text-center">
              <a
                href="https://github.com/FlorAber/ISS25-cargoservice"
                class="button primary"
                target="_blank"
              >
                GitHub Repository
              </a>
            </div>

            <div class="small-12 medium-3 text-right">
              <a class="button change" href="../../Sprint1/userDocs/sprint1_v2.html"> Next Sprint &rarr; </a>
            </div>
          </div>
        </div>
      </footer>
    </div>
  </body>
</html>
