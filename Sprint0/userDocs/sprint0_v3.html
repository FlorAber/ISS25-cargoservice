<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="it">
  <head>
    <!-- <script type="text/javascript" src="../css/issStyle.js"></script> -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"
      crossorigin="anonymous"
    ></script>
    <link
      rel="stylesheet"
      type="text/css"
      href="../../resources/_styles/style.css"
    />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>

    <title>ISS25 - Sprint 0</title>
  </head>

  <body>
    <div id="top">
      <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE - Sprint 0</h1>
    </div>
    <div class="body">
      <h2>Introduction</h2>
      <div class="remark">
        <div class="textbody">
          Lo scopo del team è quello realizzare un sistema software sulla base
          dei requisiti forniti dal cliente e presentati nel
          <a href="../../resources/TemaFinale25.html"> tema finale 2025</a>.
          <br />
          L'obiettivo dello Sprint 0 è di analizzare i requisiti forniti dal
          cliente, comprenderli pienamente e costruire un modello di riferimento
          del sistema che formalizzi i requisiti.
        </div>
      </div>

      <h2>Requirements</h2>

      <div class="remark">
        <a
          href="../../resources/TemaFinale25.html"
          class="button primary"
          target="_blank"
        >
          Client requirements
        </a>
      </div>

      <h2>Requirement analysis</h2>

      <div class="remark">
        A partire dai requisiti forniti dal cliente, si possono individuare
        diversi componenti del sistema:

        <div class="textparagraph">
          <h3>cargoservice</h3>
          <div class="textbody">
            Sistema software che si occupa della gestione della nave cargo. È in
            grado di ricevere richieste di caricamento di prodotti tramite
            l'invio di un messaggio contenente il PID del prodotto da caricare e
            si occupa di coordinare tutte le operazioni all'interno del sistema
            <br />
            <!-- Ad oggi non è possibile definire le caratteristiche della GUI non essendo specificati abbastanza requisiti. <br/> -->
            Alla richiesta di caricamento di un prodotto da parte dell'utente,
            il cargoservice potrà rispondere con un messaggio
            <i>loadaccepted()</i> in caso sia possibile procedere al carico del
            prodotto, o con un messaggio <i>loadrejected(ERRPAYLOAD)</i> che
            specifica le motivazioni per cui il caricamento non può essere
            effettuato, che possono essere:
            <ul>
              <li>Prodotto non registrato nel database</li>
              <li>
                Peso totale della hold superiore ad un limite massimo (maxLoad)
              </li>
              <li>
                Hold piena, non ci sono slot liberi a cui caricare il prodotto
              </li>
            </ul>
          </div>
        </div>

        <!-- <div class="textparagraph">
          <h3>productservice</h3>
          <div class="textbody">
            Servizio fornito dal committente che verrà integrato all'interno del sistema e si occupa della gestione del database di prodotti.
            È costituito da un'entità con la quale è possibile comunicare tramite l'invio di messaggi, in particolare per richiedere informazioni sui prodotti è
            possibile inviare un messaggio contenente il PID del prodotto di interesse e si riceverà in risposta un messaggio contenente le informazioni richieste, se il prodotto è registrato, 
            o un messaggio di errore in caso contrario.
          </div>
        </div> -->

        <div class="textparagraph">
          <h3>sensor</h3>
          <div class="textbody">
            Sottosistema incaricato della gestione di due dispositivi fisici
            forniti dal cliente: un led e un sonar. Per questo sarà costituito
            da un RaspBerryPi. Ad oggi non sono state ancora definite ulteriori
            specifiche
          </div>
        </div>

        <div class="textparagraph">
          <h3>cargorobot</h3>
          <div class="textbody">
            <!-- Il cargorobot è un componente incaricato di controllare un Differential Drive Robot fornito dal committente chiamato basicrobot, la cui documentazione è visibile al seguente
            <a href="../../resources/BasicRobot24.html">link</a>.
            Essendo il basicrobot controllabile tramite l'invio di messaggi il cargorobot non potrà essere espresso come un semplice POJO ma sarà necessario modellarlo come componente attivo.
            L'attivazione del cargorobt dovrà avvenire tramite l'invio di messaggi provenienti dal cargoservice.
            -->
            Da requisiti si evince che questo componente avrà il compito di
            occuparsi del caricamento dei container all'interno della hold. Per
            fare ciò dovrà essere in grado di:
            <ul>
              <li>Muoversi liberamente all'interno della hold</li>
              <li>
                Caricare i container che vengono consegnati in corrispondenza
                della I/O Port e posizionarli negli slot di carico disponibili
              </li>
            </ul>
            Entrambi i punti richiedono che il cargorobot sia in grado di
            muoversi all'interno della hold, evitando ostacoli e rispettando i
            vincoli fisici dell'ambiente.
            <br />

            In merito, il committente ha fornito un ambiente virtuale
            <a href="../../resources/VirtualRobot23.html">WEnv</a> che permette
            di simulare un Differential Drive Robot e ha già al suo interno una
            rappresentazione virtuale della hold così come rappresentata nei
            requisiti.
            <br />
            Viene inoltre fornito
            <a href="../../resources/BasicRobot24.html">basicrobot</a>, un
            componente software che permette di controllare il DDR virtuale
            contenuto all'interno di WEnv tramite l'invio di messaggi, si tratta
            di un'entità attiva a stati finiti, in grado di cambiare stato a
            seconda dei messaggi che riceve o autonomamente, definiamo dunque il
            basicrobot come un attore. basicrobot permette al DDR di effettuare
            singole mosse o sequenze di mosse, a seconda del messaggio di
            richiesta. Inoltre il basicrobot incorpora un
            <strong>planner</strong>, cioè un componente software che si occupa
            di calcolare autonomamente il percorso ottimale per raggiungere una
            certa posizione a partire da quella attuale del DDR. <br /><br />
            Di seguito sono riportati i messaggi con cui è possibile controllare
            con il basicrobot:
            <pre><code>  Request engage        : engage(CALLER)                // Messaggio per acquisire il controllo del basicrobot, CALLER è l'identificativo di chi richiede il controllo
  Reply   engagedone    : engagedone(ARG)
  Reply   engagerefused : engagerefused(ARG)
  Dispatch disengage    : disengage(ARG)                // Messaggio per rilasciare il controllo del basicrobot    

  Dispatch cmd          : cmd(MOVE)                     // Messaggio per far eseguire la mossa MOVE al DDR  
  
  Request step          : step(TIME)	                // Messaggio che fa muovere il DDR in avanti per un tempo pari a TIME millisecondi
  Reply stepdone        : stepdone(V)
  Reply stepfailed      : stepfailed(DURATION, CAUSE)
  
  Request  doplan       : doplan(PATH,STEPTIME)         // Messaggio che fa muovere il DDR secondo l'insieme di mosse specificate in PATH, ogni mossa ha una durata pari a STEPTIME millisecondi
  Reply doplandone      : doplandone( ARG )
  Reply doplanfailed    : doplanfailed( ARG )
  
  Dispatch setdirection : dir(D)                        // Messaggio che fa ruotare il DDR nella direzione specificata in D (up|down|left|right)
  Request moverobot     : moverobot(TARGETX, TARGETY)   // Messaggio che fa muovere il DDR alla posizione TARGETX,TARGETY calcolando autonomamente il percorso ottimale
  Reply moverobotdone   : moverobotok(ARG)
  Reply moverobotfailed : moverobotfailed(PLANDONE, PLANTODO)

  Event alarm           : alarm(X)                      // Messaggio che blocca il movimento del basicrobot
  Dispatch nextmove     : nextmove(M)
  Dispatch nomoremove   : nomoremove(M) </code></pre>
          </div>
        </div>

        <div class="textparagraph">
          <h3>hold</h3>
          <div class="textbody">
            La hold rappresenta l'ambiente in cui il DDR si muove. È formata da
            una stanza rettangolare nella quale sono presenti 5 slot di carico e
            una porta di I/O da cui entrano i container. Il DDR quando fermo si
            trova nella posizione HOME e occupa una porzione di spazio pari alle
            sue dimensioni. <br />
            La stiva della nave può dunque essere rappresentata come una griglia
            bidimensionale dove ogni punto ha coordinate discrete misurate in
            termini di dimensioni del DDR. La dimensione del DDR sarà l'unità di
            misura principale per gli spostamenti. <br />

            Lo stato di questo componente verrà aggiornato durante la normale
            esecuzione del sistema e verra visualizzato tramite la GUI,
            componente di cui al momento non si hanno sufficienti informazioni
            per compiere un'analisi dei requisiti dettagliata.

            <div class="medium-12 text-center margin-5">
              <img src="./resources/map.png" class="" alt="map" width="25%" />
            </div>
          </div>
        </div>
      </div>

      <h2>Model</h2>
      <div class="remark">
        Poichè si è osservato che il sistema richiesto dal cliente è un sistema
        costituito da un insieme di componenti attivi che comunicano tra loro
        tramite scambio di messaggi, questo risulta essere distante dalle
        tecnologie implementative tradizionali. Per costruire un modello infatti
        è necessario utilizzare un linguaggio formale per la rappresentazione di
        sistemi distribuiti, in quanto strumenti tradizionali come ad esempio
        UML, presentano un abstraction gap non trascurabile, permettendo di
        rappresentare solamente comunicazioni tra i componenti basate su
        procedure-call. Per questo motivo è stato deciso di utilizzare il
        linguaggio QAK, un Domain Specific Language che permette di modellare
        sistemi distribuiti basati su componenti attivi, chiamati attori, che
        interagiscono tramite scambio di messaggi. QAK costituisce un linguaggio
        formale, ed è per questo comprensibile anche alla macchina, risultando
        un valido strumento per la formalizzazione dei requsiti con un
        linguaggio non ambiguo.
      </div>

      <h2>Logical Model</h2>
      <div class="medium-12 text-center remark">
        <img
          src="../sprint0_system_overviewarch.png"
          class="text-center"
          alt="map"
          width="25%"
        />
      </div>

      <h2>Test plans</h2>
      <div class="remark">
        <div class="textbody">
          Il piano di test che è possibile stilare in questa fase del progetto è
          relativo al verificare che il corebusiness risponda alle richieste di
          carico con i messaggi attesi, <i>loadaccepted()</i> o
          <i>loadrejected(ERRPAYLOAD)</i>.
          <pre
            style="
              width: 80%;
              padding: 1px;
              border: 5px solid #ccc;
              border-radius: 5px;
              overflow: auto;
            "
          ><code>
// Test load request accepted
  @Test
    public void testLoadRequestAccepted() throws Exception {
        //Costruzione di richiesta con PID valido.

        String load_req = CommUtils.buildRequest("tester",
                "load_product", "load_product(1)", 
                "cargoservice").toString();
        
        System.out.println("Richiesta: " + load_req);
        
        //Risposta accettata perchè peso legato al PID inferiore di MaxLoad 
        String response = conn.request(load_req);
        
        System.out.println("Risposta: " + response); // Risposta contenente lo slot libero dove posizionare il container
        
        //Verifica che sia stata accettata
        assertTrue("TEST: richiesta accettata", 
                 response.contains("load_accepted"));
    }



// Test load request rejected weight exceeded
    @Test
    public void testLoadRequestRejectedWeightExceeded() throws Exception {
        //Costruzione di richiesta con PID non valido.

        String load_req = CommUtils.buildRequest("tester",
                "load_product", "load_product(5)", 
                "cargoservice").toString();
        
        System.out.println("Richiesta: " + load_req);
        
        //Risposta rifiutata perchè PID non registrato
        String response = conn.request(load_req);
        
        System.out.println("Risposta: " + response); // Risposta contenente l'errore
        
        //Verifica che sia stata rifiutata
        assertTrue("TEST: richiesta rifiutata", 
                 response.contains("load_rejected")
                 && response.contains("overweight"));
    }


// Test load request rejected no slot available
    @Test
    public void testLoadRequestRejectedNoSlot() throws Exception {
        //Costruzione di richiesta con PID non valido.

        String load_req = CommUtils.buildRequest("tester",
                "load_product", "load_product(6)", 
                "cargoservice").toString();
        
        System.out.println("Richiesta: " + load_req);
        
        //Risposta rifiutata perchè PID non registrato
        String response = conn.request(load_req);
        
        System.out.println("Risposta: " + response); // Risposta contenente l'errore
        
        //Verifica che sia stata rifiutata
        assertTrue("TEST: richiesta rifiutata", 
                 response.contains("load_rejected")
                 && response.contains("noslotavailable"));
    }

// Test load request rejected PID not registered
    @Test
    public void testLoadRequestRejectedPIDNotRegistered() throws Exception {
        //Costruzione di richiesta con PID non valido.

        String load_req = CommUtils.buildRequest("tester",
                "load_product", "load_product(999)", 
                "cargoservice").toString();
        
        System.out.println("Richiesta: " + load_req);
        
        //Risposta rifiutata perchè PID non registrato
        String response = conn.request(load_req);
        
        System.out.println("Risposta: " + response); // Risposta contenente l'errore
        
        //Verifica che sia stata rifiutata
        assertTrue("TEST: richiesta rifiutata", 
                 response.contains("load_rejected")
                 && response.contains("pidnotregistered"));
    }

</code></pre>
          <br />
          <br />
        </div>
      </div>

      <h2>Work plans</h2>
      <div class="remark">
        <div class="textbody">
          Il progetto verrà sviluppato in 3 sprint, secondo un ordine di
          priorità delle funzionalità:
          <ol>
            <li>
              Sprint 1 - Core Business : si svilupperà un modello che realizzi
              le funzionalità principali del sistema, tra cui il movimento del
              basicrobot. Tempo di sviluppo stimato 50 ore uomo.
            </li>
            <li>
              Sprint 2 - Sensor : si realizzerà la parte del sistema che si
              occupa della gestione di led e sonar. Tempo di sviluppo stimato 40
              ore uomo.
            </li>
            <li>
              Sprint 3 - GUI : si realizzerà l'interfaccia grafica che
              permetterà di visualizzare lo stato del sistema. Tempo di sviluppo
              stimato 20 ore uomo.
            </li>
          </ol>
        </div>

        <footer class="footer">
          <div class="grid-container fluid">
            <div class="grid-x grid-margin-x align-middle">
              <div class="small-12 medium-3 text-center">
                <a class="button change disabled"> &larr; Previous Sprint </a>
              </div>

              <div class="small-12 medium-4 text-center">
                Fasano Andrea : andrea.fasano3@studio.unibo.it <br />
                <!-- 0001189592 -->
                Florian Alberto : alberto.florian@studio.unibo.it <br />
                <!-- 0001189572 -->
                Sampaoli Giacomo : giacomo.sampaoli@studio.unibo.it
                <!-- 0001176431 -->
              </div>

              <div class="small-12 medium-2 align-middle text-center">
                <a
                  href="https://github.com/FlorAber/ISS25-cargoservice"
                  class="button primary"
                  target="_blank"
                >
                  GitHub Repository
                </a>
              </div>

              <div class="small-12 medium-3 text-right">
                <a
                  class="button change"
                  href="../../Sprint1/userDocs/sprint1_v2.html"
                >
                  Next Sprint &rarr;
                </a>
              </div>
            </div>
          </div>
        </footer>
      </div>
    </div>
  </body>
</html>
