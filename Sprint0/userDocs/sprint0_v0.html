<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="it">
  <head>
    <!-- <script type="text/javascript" src="../css/issStyle.js"></script> -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"
      crossorigin="anonymous"
    ></script>
    <link rel="stylesheet" type="text/css" href="../../resources/_styles/style.css" />

    <title>ISS25 - Sprint 0</title>
  </head>

  <body>
    <div id="top">
      <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE - Sprint 0</h1>
    </div>
    <div class="body">
      <h2>Introduction</h2>
      <div class="remark">
        <div class="textbody">
          Lo scopo del team è quello realizzare un sistema software sulla base
          dei requisiti forniti dal cliente e presentanti nel
          <a href="../../resources/TemaFinale25.html"> tema finale 2025 </a>.
          <br />
          L'obiettivo dello Sprint 0 è di analizzare i requisiti forniti dal
          cliente, comprenderli pienamente e costruire un modello di riferimento
          del sistema che illustri i macro-componenti in gioco.
          <!-- , evidenziando le componenti in gioco e come queste
          interagiscono -->
        </div>
      </div>

      <h2>Requirements</h2>

      <div class="remark">
        <a
          href="../../resources/TemaFinale25.html"
          class="button primary"
          target="_blank"
        >
          Client requirements
        </a>
      </div>

      <h2>Requirement analysis</h2>

      <div class="remark">
        Si è osservato che il sistema richiesto dal cliente è costituito da un
        insieme di componenti attivi che comunicano tra loro, tramite scambi di
        messaggi, per raggiungere un obiettivo comune. <br />
        Per questo motivo i componenti che andranno a formare il sistema sono:

        <div class="textparagraph">
          <h3>cargomanager</h3>
          <div class="textbody">
            Componente principale del sistema, ad esso è affidata la gestione
            della nave cargo. Riceve le richieste di caricamento, si interfaccia
            con <em>productservice</em> per verificare se il prodotto è
            registrato e qual'è il suo peso, controlla se la capienza della
            stiva è sufficiente per il caricamento e se ci sono slot liberi.
            Dopo queste verifiche risponde alla richiesta l'esito della stessa.
            <br />
            Oltre a ciò interagisce con una GUI per rendere visibile lo stato
            del sistema all'utente, ad oggi non è possibile definire le
            caratteristiche della GUI non essendo specificati abbastanza
            requisiti.
          </div>
        </div>

        <div class="textparagraph">
          <h3>productservice</h3>
          <div class="textbody">
            Componente che si occupa della gestione del database dei prodotti,
            contenente PID e peso dei prodotti registrati, riceve richieste da
            cargomanager e restituisce le informazioni del prodotto (PID e
            peso), nel caso sia registato, o un messaggio di errore nel caso non
            lo sia.
          </div>
        </div>

        <div class="textparagraph">
          <h3>sensors</h3>
          <div class="textbody">
            Componente formato da un RaspBerryPy munito di led e sonar forniti
            dal cliente. Led e sonar vengono gestiti da due servizi separati:
            <ul>
              <li>
                Sonarmng: invia un segnale al cargomanager se rileva la presenza
                di un pacco nella I/O Port o invia un segnale di interruzione a
                tutto il sistema nel caso di errore nella rilevazione
              </li>
              <li>
                Ledmng: rimane in attesa di interruzioni provenienti dal sonar
                che lo facciano accendere o spegnere in caso di guasti e al
                momento della loro risoluzione
              </li>
            </ul>
          </div>
        </div>

        <div class="textparagraph">
          <h3>basicrobot</h3>
          <div class="textbody">
            Attore fornito dal committente, può essere controllato tramite
            l'invio di messaggi ed è in esecuzione su un nodo separato rispetto
            agli altri componenti.
          </div>
        </div>

        <div class="textparagraph">
          <h3>map</h3>
          <div class="textbody">
            La mappa rappresenta l'ambiente in cui il robot si muove. È formata
            da una stanza rettangolare nella quale sono presenti 5 slot di
            carico e una porta di I/O da cui entrano i container. Il robot
            quando fermo si trova nella posizione HOME, posta nell'angolo in
            alto a sinistra della mappa e occupa una porzione di spazio pari
            alle sue dimensioni. <br />
            <div class="medium-12 text-center margin-5">
              <img src="./resources/map.png" class="" alt="map" width="25%" />
            </div>
          </div>
        </div>
      </div>

      <h2>Model</h2>
      <div class="remark">
        <h3>Perchè QAK</h3>
        <div class="textbody">
          Per la realizzazione del sistema si è deciso di utilizzare il
          linguaggio QAK in quanto questo offre un valido stumento per la
          velocizzazione dello sviluppo e della prototipazione. QAK infatti
          offre la possibilità non solo di creare attori che comunicano
          attraverso la rete ma in caso di esecuzione di più attori in localhost
          lo scambio di messaggi avviene tramite buffer locale, riducendo il
          carico della rete. Inoltre QAK sfrutta il linguaggio Kotlin, dove
          vengono utilizzate le Kotlin Routines, più leggere dei thread e quindi
          più adatte all'esecuzione simultanea su macchine con prestazioni
          limitate, come può essere un RaspBerryPy.
        </div>
      </div>

      <h2>Logical Architecture</h2>
      <div class="medium-12 text-center remark">
        <img
          src="../sprint0_system_overviewarch.png"
          class="text-center"
          alt="map"
          width="25%"
        />
      </div>

      <h2>Test plans</h2>
      <div class="remark">
        <div class="textbody">
          Lo scopo della fase di test è quello di testare il funzionamento del
          core business, cioè dei componenti <strong> cargomanager </strong> e
          <strong> productservice</strong>. Per farlo si è deciso di procedere
          inizialmente con un approccio Unit Test per poi proseguire con
          l'Integration Test al termine dei primi. <br />
          <ul>
            <li>
              Un'entità esterna andrà ad inoltrare una richiesta di carico al
              cargomanager e ne verficherà l'esito. Per rispondere a questa
              richiesta il cargomanager interagirà sempre con l'entità esterna
              che avrà il compito di simulare il comportamento del
              productservice. Se l'esito della richiesta sarà positivo l'entità
              esterna invierà un segnale di carico emulando il comportamento del
              sonar.
            </li>
            <li>
              Un'entità esterna avrà lo scopo di simulare il comportamento del
              cargomanager nella comunicazione con il productservice. Inviando
              appositi messaggi per effettuare la ricerca dei prodotti
              all'interno del database
            </li>
          </ul>
        </div>
      </div>

      <h2>Work plans</h2>
      <div class="remark">
        <div class="textbody">
          Il progetto verrà sviluppato in 3 sprint, secondo un ordine di
          priorità delle funzionalità:
          <ol>
            <li>
              <bold>Sprint 1 - Core Business : </bold> si svilupperà un modello che realizzi le funzionalità principali del sistema, tra cui il movimento del basicrobot
            </li>
            <li><bold>Sprint 2 - Sensor : </bold> si realizzerà la parte del sistema che si occupa della gestione di led e sonar </li>
            <li><bold>Sprint 3 - GUI : si realizzerà l'interfaccia grafica che permetterà di visualizzare lo stato del sistema </bold></li>
          </ol>
      </div>

      <!-- <h2>Project</h2>

      <div class="remark">...</div>

      <h2>Testing</h2>

      <div class="remark">...</div>

      <h2>Deployment</h2>

      <div class="remark">...</div>

      <h2>Maintenance</h2>

      <div class="remark">...</div> -->

      <footer class="footer">
        <div class="grid-container fluid">
          <div class="grid-x grid-margin-x align-middle">
            <div class="small-12 medium-3 text-center">
              <a class="button change disabled"> &larr; Previous Sprint </a>
            </div>

            <div class="small-12 medium-4 text-center">
              Fasano Andrea : andrea.fasano3@studio.unibo.it <br />
              <!-- 0001189592 -->
              Florian Alberto : alberto.florian@studio.unibo.it <br />
              <!-- 0001189572 -->
              Sampaoli Giacomo : giacomo.sampaoli@studio.unibo.it
              <!-- 0001176431 -->
            </div>

            <div class="small-12 medium-2 align-middle text-center">
              <a
                href="https://github.com/FlorAber/ISS25-cargoservice"
                class="button primary"
                target="_blank"
              >
                GitHub Repository
              </a>
            </div>

            <div class="small-12 medium-3 text-right">
              <a class="button change disabled"> Next Sprint &rarr; </a>
            </div>
          </div>
        </div>
      </footer>
    </div>
  </body>
</html>
