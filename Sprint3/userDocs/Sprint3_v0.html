<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="it">
  <head>
    <!-- <script type="text/javascript" src="../css/issStyle.js"></script> -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"
      crossorigin="anonymous"
    ></script>
    <!-- <link rel="stylesheet" type="text/css" href="../../resources/_styles/style.css" /> -->
    <link rel="stylesheet" type="text/css" href="./css/style.css" />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>

    <title>ISS25 - Sprint 3</title>
  </head>

  <body>
    <div id="top">
      <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE - Sprint 3</h1>
    </div>
    <div class="body">
      <h2>Introduction</h2>
      <div class="remark">
        <div class="textbody grid-x grid-margin-x align-middle">
          <div class="medium-8">
            Nello Sprint precedente sono state analizzate le problematiche ed è
            stato progettato il contesto operativo del componente Sensor
            L'output finale è stato una modellazione di alto livello del sistema
            e una prima implementazione funzionante (figura a destra).
            <br />
            <br />
            L'obiettivo dello Sprint 3 è di analizzare le problematiche relative
            allo sviluppo di un'interfaccia grafica per l'utente finale (GUI) e
            realizzarne un'implementazione funzionante, integrandola con i
            componenti del sistema già modellati neglle fasi precedenti.
          </div>
          <div class="medium-4">
            <img
              src="../../Sprint2/sprint2_sensors_modelarch.png"
              alt="Sprint 2 System Overview"
              width="100%"
            />
          </div>
        </div>
      </div>

      <h2>Requirements</h2>
      <div class="remark">
        Il sistema deve soddisfare il seguente requisito:
        <ul>
          <li>
            Deve fornire un'interfaccia grafica web dinamica che consenta agli
            utenti di visualizzare in tempo reale lo stato della hold.
          </li>
        </ul>
      </div>

      <h2>Problem analysis</h2>
      <div class="remark">
        <!-- Per soddisfare il requisito sopra elencato, è necessario affrontare le seguenti problematiche: -->

        <div class="textparagraph">
          <h3>Come modellare GUI?</h3>
          <div class="textbody">
            Da requisiti la GUI deve essere accessibile via web, pertanto occorre implementarla come applicazione web-based. Questo consente di rendere la GUI accessibile
            da qualsiasi dispositivo dotato di un browser web, senza la necessità di installare software aggiuntivo.
            <br></br>
            A questo scopo si suggerisce di utilizzare un framework di sviluppo come SpringBoot, 
            il quale permette di sviluppare applicazioni web in Java
            in grado di interfacciarsi agevolmente con i sistemi precedentemente implementati.
            Si suggerisce pertanto di modellare la GUI non come attore a stati finiti ma come un'entità separata in grado di comunicare con cargoservice.
          </div>
        </div>
        <div class="textparagraph">
          <h3>Come estrarre le informazioni sullo stato della hold?</h3>
          <div class="textbody">
            L'attore <strong>holdmanager</strong>, in esecuzione nel contesto <i>ctx_cargo</i>, contesto del corebusiness del sistema
            aggiorna costantemente lo stato della hold in seguito al caricamento prodotti.
            Per consentire alla GUI di visualizzare lo stato della hold, si possono esaminare molteplici modalità alternative, come ad esempio:
            <ul>
              <li>Implementare un'interfaccia RESTful nell'attore <strong>holdmanager</strong> per consentire alla GUI di effettuare richieste HTTP e ottenere lo stato della hold in formato JSON.</li>
              <li>Utilizzare un sistema di messaggistica (ad esempio MQTT o WebSocket) per inviare aggiornamenti in tempo reale dalla holdmanager alla GUI ogni volta che lo stato della hold cambia.</li>
              <li>Implementare un meccanismo di polling nella GUI che richieda periodicamente lo stato della hold all'attore holdmanager.</li>
              <li>Prevedere l' aggiornamento di una risorsa CoAP da parte di <strong>holdmanager</strong> e recuperarne lo stato ad ogni cambiamento.</li>
            </ul>
            Si suggerisce di adottare l'ultima soluzione, in quanto coerente con le tecnologie già adottate nel sistema e con i paradigmi di comunicazione utilizzati,
            inoltre in fase di progettazione dell'attore qak <strong>holdmanager</strong> è già stato previsto l'aggiornamento di una risorsa CoAP, che contiene la
            descrizione dello stato della hold in formato JSON.
          </div>
        </div>
        <div class="textparagraph">
          <h3>Come visualizzare lo stato della hold in una GUI?</h3>
          <div class="textbody">
            Le informazioni import riguardanti la hold che devono essere visualizzate sono:
            <ul>
              <li> Che slot sono occupati e le informazioni riguardanti i prodotti che contengono (PID, Nome, Peso)</li>
              <li> Peso totale della hold e peso massimo che può assumere</li>
            </ul>
            Queste informazioni devono essere rappresentate in modo chiaro e possono essere interamente estrapolate dalla stringa JSON fornita dall'attore <strong>holdmanager</strong>
            <br/><br/>
            Per realizzare la GUI ed implementare le logiche necessarie all'estrazione dello stato della hold dal core business, si suggerisce di realizzare un progetto SpringBoot 
            Per estrarre le informazioni dall'attore <strong>holdobserver</strong> si consiglia di realizzare un progetto 
          </div>
          </div>
      </div>

      <h2>Logical Architecture</h2>
      <div class="medium-12 text-center remark">
        <img
          src="./resources/sprint3_logicalArch.png"
          class="text-center"
          alt="map"
          width="75%"
        />
      </div>

      <h2>Test plans</h2>

      <h2>Project</h2>
      <div class="remark">
          Per lo sviluppo del progetto della web gui è stato scelto di adottare
          il framework SpringBoot, un framework Java per lo sviluppo di applicazioni web
          che dunque si integra bene con le tecnologie utilizzate nel sistema e le librerie
          fornite dal committente.
          <br>
          Le classi che ricoprono ruoli principali sono:
          <ul>
            <li>CoapToWS: componente che funge da client CoAP e gestisce degli aggiornamenti.</li>
            <li>WSHandler: componente che sfruttando il framework SpringBoot per la gestione di WebSocket.</li>
            <li>HoldStateService: componente che fornisce accesso TCP al contesto di esecuzione di cargoservice e interrogazione su richiesta dello stato.</li>
          <div class="textparagraph">
            <h3>comportamento CoapToWS</h3>
            <div class="textbody">
              La classe CoapToWS implementa un osservatore CoAP che si iscrive alla risorsa <i>holdstate</i>
              esposta dall'attore <strong>holdmanager</strong>. 

              <pre>
                <code>package unibo.webgui.coap;

import org.eclipse.californium.core.CoapClient;
import org.eclipse.californium.core.CoapHandler;
import org.eclipse.californium.core.CoapObserveRelation;
import org.eclipse.californium.core.CoapResponse;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import jakarta.annotation.PostConstruct;
import unibo.basicomm23.utils.CommUtils;
import unibo.webgui.utils.HoldResponseParser;
import unibo.webgui.ws.WSHandler;

@Component
public class CoapToWS {
    private static final String COAP_ENDPOINT_HOLD = "coap://127.0.0.1:8014/ctx_cargo/holdmanager";
    private static final String COAP_ENDPOINT_ROBOT = "coap://127.0.0.1:8014/ctx_cargo/cargorobot";

    private CoapClient clienthold;
    private CoapClient clientrobot;
    private CoapObserveRelation observeRelationHold;
    private CoapObserveRelation observeRelationRobot;

    @Autowired
    private WSHandler wsHandler;
    
    @PostConstruct
    public void init() {
        // inizializza clienthold e clientrobot
        clienthold = new CoapClient(COAP_ENDPOINT_HOLD);
        observeRelationHold = clienthold.observe(new CoapHandler() {
            @Override
            public void onLoad(CoapResponse response) {
                String content = response.getResponseText();
                CommUtils.outblue("CoAP payload - hold: " + content);

                try {
                    JSONObject payload = HoldResponseParser.parseHoldState(content);
                    if (payload != null) {
                        wsHandler.sendToAll(payload.toString());
                    } else {
                        CommUtils.outred("Evento CoAP non valido: " + content);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            @Override
            public void onError() {
                System.err.println("Errore nell'osservazione CoAP su " + COAP_ENDPOINT_HOLD);
            }
        });
        System.out.println("Iniziata osservazione CoAP su: " + COAP_ENDPOINT_HOLD);
        
        clientrobot = new CoapClient(COAP_ENDPOINT_ROBOT);
        observeRelationRobot = clientrobot.observe(new CoapHandler() {
            @Override
            public void onLoad(CoapResponse response) {
                String content = response.getResponseText();
                CommUtils.outblue("CoAP payload - robot: " + content);

                try {
                    JSONObject payload = HoldResponseParser.parseRobotState(content);
                    if (payload != null) {
                        wsHandler.sendToAll(payload.toString());
                    } else {
                        CommUtils.outred("Evento CoAP non valido: " + content);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

            @Override
            public void onError() {
                System.err.println("Errore nell'osservazione CoAP su " + COAP_ENDPOINT_ROBOT);
            }
        });
        System.out.println("Iniziata osservazione CoAP su: " + COAP_ENDPOINT_ROBOT);
    }
}
                </code>
              </pre>
 Ogni volta che la risorsa viene aggiornata
              l'osservatore riceve l'aggiornamento, estrae il payload della risposta e grazie ad una classe 
              ausiliaria <strong>HoldResponseParser</strong> estrae le informazioni rilevanti dallo stato della hold quali 
              pid, nome e peso dei prodotti caricati.
              (lo stato della hold in formato JSON) e inoltrandolo a tutti i client WebSocket
              connessi tramite la classe <strong>WSHandler</strong>.

              <pre>
                <code>package unibo.webgui.utils;

import org.json.JSONObject;
import org.json.JSONArray;
import java.util.ArrayList;
import java.util.List;

public class HoldResponseParser {
	
    public static JSONObject parseHoldState(String message) {
        String jsonString = null;
		JSONObject payload = new JSONObject();
		
		if (message.startsWith("'") && message.endsWith("'")) {
			jsonString = message.substring(1, message.length()-1);
		} 
		else if(message.startsWith("{")) {
			jsonString = message;
		}

    
		System.out.println(jsonString);
		JSONObject holdstate = new JSONObject(jsonString);
		
		int maxload = holdstate.getInt("MAXLOAD");
		JSONArray pidsJSON = holdstate.getJSONArray("pids");
		JSONArray namesJSON = holdstate.getJSONArray("names");
		JSONArray weightsJSON = holdstate.getJSONArray("weights");

		List<Integer> pids = new ArrayList<>();
		List<String> names = new ArrayList<>();
		List<Integer> weights = new ArrayList<>();

		for (int i = 0; i < pidsJSON.length(); i++) {
		    pids.add(pidsJSON.getInt(i));
		}

		for (int i = 0; i < namesJSON.length(); i++) {
		    names.add(namesJSON.getString(i));
		}

		for (int i = 0; i < weightsJSON.length(); i++) {
		    weights.add(weightsJSON.getInt(i));
		}
		
		payload.put("maxload", maxload);
		payload.put("pids", pids);
		payload.put("names", names);
		payload.put("weights", weights);
            
		return payload;
    }
  }
                </code>
              </pre>

              </div>
              </div>
            <div class="textparagraph">
            <h3>comportamento WSHandler</h3>
            <div class="textbody">
              Si tratta di un componente SpringBoot che gestisce le connessioni WebSocket con i client.
              Funge da "intermediario" tra il componente CoapToWS e i client WebSocket.
              <pre>
                <code>package unibo.webgui.ws;

import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

@Component
public class WSHandler extends TextWebSocketHandler {
    private final List<WebSocketSession> sessions = new CopyOnWriteArrayList<>();

    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        sessions.add(session);
    }

    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
        sessions.remove(session);
    }

    public void sendToAll(String message) throws IOException {
        for (WebSocketSession session : sessions) {
            if (session.isOpen()) {
                session.sendMessage(new TextMessage(message));
            }
        }
    }
}
                </code>
              </pre>
              Nel medesimo package è presente la classe di configurazione WebSocket <strong>WebSocketConfig</strong> che implementa
              l'interfaccia WebSocketConfigurer di SpringBoot per registrare il gestore WSHandler
              all'endpoint "/ws/holdstate", rendendolo accessibile ai client WebSocket.
              <pre>
                <code>package unibo.webgui.ws;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    private final WSHandler handler;

    public WebSocketConfig(WSHandler handler) {
        this.handler = handler;
    }
    
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(handler, "/holdupdates")
                .setAllowedOrigins("*");
    }
}
                </code>
              </pre>
              </div>
              </div>
            <div class="textparagraph">
            <h3>comportamento HoldStateService</h3>
            <div class="textbody">
              Questo componente fornisce un'interfaccia TCP per interrogare lo stato della hold
              direttamente dal contesto di esecuzione di cargoservice.
              <pre>
                <code>package unibo.webgui.service;

import org.json.JSONObject;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import unibo.basicomm23.interfaces.IApplMessage;
import unibo.basicomm23.interfaces.Interaction;
import unibo.basicomm23.msg.ProtocolType;
import unibo.basicomm23.utils.CommUtils;
import unibo.basicomm23.utils.ConnectionFactory;
import unibo.webgui.utils.HoldResponseParser;
import unibo.webgui.ws.WSHandler;

@RestController
public class HoldStateService {

    @Autowired
    private WSHandler wsHandler;

    private Interaction conn;

    public HoldStateService() {
        try {
            conn = ConnectionFactory.createClientSupport23(ProtocolType.tcp, "127.0.0.1", "8014");
        } catch (Exception e) {
            System.err.println("Errore nella connessione TCP iniziale: " + e.getMessage());
        }
    }

    @GetMapping("/holdstate")
    public String getHoldState() {
        try {
            IApplMessage request = CommUtils.buildRequest("webgui", "getholdstate", "getholdstate(X)", "holdmanager");
            IApplMessage response = conn.request(request);
            CommUtils.outblue("hold-state query response:" + response.msgContent());
            
            String jsonString = response.msgContent().substring(
                    "'holdstate(".length(), 
                    response.msgContent().length() - 2
                );
            
            JSONObject payload = HoldResponseParser.parseHoldState(jsonString);
            if (payload != null) {
                wsHandler.sendToAll(payload.toString());
                return payload.toString();
            } else {
                return "{\"error\":\"payload nullo\"}";
            }
        } catch (Exception e) {
            e.printStackTrace();
            return "{\"error\":\"" + e.getMessage() + "\"}";
        }
    }
    
}

                </code>
              </pre>
            </div>
            </div>
            <div class="textparagraph">
            <h3>Estensioni</h3>
            <div class="textbody">
              Sebbene non espressamente richiesto dai requisiti, è stato implementato un meccanismo di inserimento di richieste di caricamento
              dei prodotti tramite la GUI, così da poter rimuovere la dipendenza da attori esterni per il caricamento dei prodotti. (nel corso 
              dello sviluppo del core business era stato previsto un attore <strong>mockuser</strong> per questo scopo). Lo 
              scopo è quello di riuscire a trasmettere all'attore <strong>cargoservice</strong> una <i>loadrequest(pid)</i> opportunamente
              formattata.
              <br></br>
              è stata creata una nuova classe <strong>CallerService</strong> per implementare questa funzionalità. 
              <pre>
                <code>package unibo.webgui.service;

import org.json.JSONObject;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import unibo.basicomm23.interfaces.IApplMessage;
import unibo.basicomm23.interfaces.Interaction;
import unibo.basicomm23.msg.ProtocolType;
import unibo.basicomm23.utils.CommUtils;
import unibo.basicomm23.utils.ConnectionFactory;
import unibo.webgui.utils.HoldResponseParser;
import unibo.webgui.ws.WSHandler;

@RestController
public class CallerService {

    @Autowired
    private WSHandler wsHandler;

    private Interaction conn;

    public CallerService() {
        try {
            conn = ConnectionFactory.createClientSupport23(ProtocolType.tcp, "127.0.0.1", "8014");
        } catch (Exception e) {
            System.err.println("Errore nella connessione TCP iniziale: " + e.getMessage());
        }
        try {
            conn = ConnectionFactory.createClientSupport23(ProtocolType.tcp, "127.0.0.1", "8014");
            CommUtils.outgreen("Connessione TCP creata correttamente");
        } catch (Exception e) {
            e.printStackTrace(); 
            conn = null;
        }
    }

    @GetMapping("/loadrequest")
    public String callCargoservice(@RequestParam("pid") String pid) {
        try {
        	CommUtils.outblue("send request to cargoservice");
    	 	IApplMessage getreq = CommUtils.buildRequest ("webgui", "loadrequest","loadrequest("+pid+")", "cargoservice");
            IApplMessage answer = conn.request(getreq);
            CommUtils.outgreen("response" + answer);
            return answer.msgContent();
        } catch (Exception e) {
            e.printStackTrace();
            return "{\"error\":\"" + e.getMessage() + "\"}";
        }
    }
}

                </code>
              </pre>
            </div>
            </div>
            </div>
          </div>
          </div>
          </div>

      </div>
      
      <h2>System Design</h2>
      <div class="remark">
      Dopo aver terminato questa fase di progettazione e integrazione con le componenti gia sviluppate, il sistema assume la seguente architettura
      
      <div class="medium-12 text-center remark">
        <img
          src="./resources/sprint3_systemDesign.png"
          class="text-center"
          alt="map"
          width="75%"
        />
      </div>
      </div>

      <h2>Considerazioni finali e Deployment</h2>

      <footer class="footer">
        <div class="grid-container fluid">
          <div class="grid-x grid-margin-x align-middle">
            <div class="small-12 medium-3 text-center">
              <a
                class="button change"
                href="../../Sprint2/userDocs/sprint2_v0.html"
              >
                &larr; Previous Sprint
              </a>
            </div>

            <div class="small-12 medium-4 text-center">
              Fasano Andrea : andrea.fasano3@studio.unibo.it <br />
              <!-- 0001189592 -->
              Florian Alberto : alberto.florian@studio.unibo.it <br />
              <!-- 0001189572 -->
              Sampaoli Giacomo : giacomo.sampaoli@studio.unibo.it
              <!-- 0001176431 -->
            </div>

            <div class="small-12 medium-2 align-middle text-center">
              <a
                href="https://github.com/FlorAber/ISS25-cargoservice"
                class="button primary"
                target="_blank"
              >
                GitHub Repository
              </a>
            </div>

            <div class="small-12 medium-3 text-right">
              <a class="button change disabled"> Next Sprint &rarr; </a>
            </div>
          </div>
        </div>
      </footer>
    </div>
  </body>
</html>
