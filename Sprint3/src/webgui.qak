System sprint3

//Request get_hold_state : get_hold_state(X)
//Reply   hold_state     : hold_state(JSonString) for get_hold_state

Event productloaded : productloaded(X) 
Event holdupdated : holdupdated(JSONSTATE)

Context ctx_webgui       ip [host="localhost" port=8017]
Context ctx_cargo		 ip [host="127.0.0.1" port=8014]


//ExternalQActor holdmanager context ctx_cargo


QActor webguiobserver context ctx_webgui {
	[# var CurrentState = {} #]
	
	State s0 initial {
		delay 2000
		println("$name | START") color yellow
	}
	Transition t
		whenEvent holdupdated -> handleholdupdate
		whenEvent productloaded -> handleholdupdate
		
	State handleholdupdate {
		println("$name : updating")

		onMsg (holdupdated : holdupdated(JSONSTATE)) {
			[#
	            val holdstate = payloadArg(0)
	        #]
	        println("$name : hold updated - $holdstate") color yellow
		}
	}
}

//QActor webgui context ctx_webgui {
//    [#
//        var CurrentState = "{}"
//
//        fun stateUpdate(json: String){
//            CurrentState = json
//            println("Hold State: $CurrentState") 
//        }
//    #]
//
//    State init initial {
//        delay 1000
//        println("$name | START")
//        
//        
//        println("$name | getting hold state for the first time")
//		// chiedo a cargoservice che girerà ad hold
////        request cargoservice -m get_hold_state : get_hold_state(si)
////    	request hold -m get_hold_state : get_hold_state(si)
//    }
//    Transition t0
//        whenEvent holdupdated -> handleHoldUpdate
//
//
//    State handleHoldState {
//    	// incredibile, a quanto pare se tolgo questa stampa crasha tutto...
//    	println("$name | processing reply")
//    	
//    	onMsg( hold_state : hold_state(JSON) ) {
//	        [#
//	            val receivedState = payloadArg(0)
//	            println("$name | initial hold state: $receivedState") 
//	            stateUpdate(receivedState)
//	        #]
//        }
//    }
//    Goto listening
//
//
//    State listening {
//        println("$name | waiting for hold updates")
//    }
//    Transition t1
//    	whenEvent hold_update -> update_webgui
//    	// questo è il dispatch generato da updateResource,
//    	// in teoria dovrebbe funzionare, ma nella pratica non è così...
//    	// uso anche l'evento sopra per questo motivo
//        whenMsg hold_update -> update_webgui 
//
//
//   State update_webgui {
//   		println("$name | update $currentMsg") color red 
//   		
//		[#
//            var UpdateJson = payloadArg(0)
//            println("$name | hold update received: $UpdateJson") 
//            stateUpdate(UpdateJson)
//        #]
//
//        // per il test
//        updateResource [# CurrentState #]
//    }
//    Goto listening
//}