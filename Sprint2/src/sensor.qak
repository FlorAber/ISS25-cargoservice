System sprint2_sensors_model


Event doDeposit : doDeposit(X) 					 // user to cargoservice
Event waitingForDeposit : waitingfordeposit(X)    // sent after load request accepted, used to trigger the sonar sensor
Event stopWaitingForDeposit : stopWaitingForDeposit(X)
// TEMPORANEA PER GESTIRE LA FINE DEL CARICAMENTO E AGGIORNARE LO STATO INTERNO DELL'HOLDMANAGER, SOSTITUIBILE CON ALTRO
Event productloaded : productloaded(X) 
Event alarm : alarm(ARG) 

Event sonaralert : sonaralert(X)	 // inizia stato di alert	
Event sonarok    : sonarok(X)		 // terminato stato di alert

Event stopthesystem:stopthesystem(X) 		// Evento interno per fermare gli altri attori NON USATO DAL SONAR
Event resumethesystem:resumethesystem(X)	// Evento interno per far ripartire gli altri attori NON USATO DAL SONAR

Event measurement	: measurement(CM) // evento di invio della misurazione rilevata


Request loadrequest: loadrequest(PID)
Reply loadaccepted : loadaccepted(X) for loadrequest // cargoservice to mock
Reply loadrejected : loadrejected(X) for loadrequest // cargoservice to mock




//Context ctx_cargo  ip  [host="127.0.0.1" port=8014]
//
//Context ctx_basicrobot  ip  [host="127.0.0.1" port=8020]
//Context ctxproductservice ip [ host="127.0.0.1" port=8111]

Context ctx_sensor  ip  [host="localhost" port=8016]

//ExternalQActor productservice context ctxproductservice
//ExternalQActor basicrobot context ctx_basicrobot
//ExternalQActor cargoservice context ctx_cargo

QActor sonarsimulator context ctx_sensor{
	State s0 initial{
		delay 2000
		println("$name: starting") color cyan
	}
	Goto work
	
	State work{
		delay 1000 // attendo che sonarlistener entri in attesa
		
		// misurazioni non consistenti
		emitlocalstream measurement      : measurement(30)
	    delay 1000
		emitlocalstream measurement      : measurement(15)
	    delay 1000
		emitlocalstream measurement      : measurement(10)
	    delay 1000
		emitlocalstream measurement      : measurement(0)
	    delay 1000
		emitlocalstream measurement      : measurement(40)
		
		// assente per 4 secondi
		emitlocalstream measurement      : measurement(20)
	    delay 1000
	    emitlocalstream measurement      : measurement(20)
	    delay 1000
	    emitlocalstream measurement      : measurement(20)
	    delay 1000
	    emitlocalstream measurement      : measurement(20)
	    delay 1000
	    
		// presente per 3 secondi
		emitlocalstream measurement      : measurement(10)
	    delay 1000
	    emitlocalstream measurement      : measurement(10)
	    delay 1000
	    emitlocalstream measurement      : measurement(10)
	    delay 1000
	    
	    // di nuovo presente per 3 secondi
	    emitlocalstream measurement      : measurement(10)
	    delay 1000
	    		emit waitingForDeposit : waitingForDeposit(1)
	    emitlocalstream measurement      : measurement(10)
	    delay 1000
	    emitlocalstream measurement      : measurement(10)
	    delay 1000
	   
	     
	    // guasto per 5 secondi
	    emitlocalstream measurement      : measurement(31)
	    delay 1000
	    emitlocalstream measurement      : measurement(31)
	    delay 1000
	    emitlocalstream measurement      : measurement(31)
	    delay 1000
	    emitlocalstream measurement      : measurement(31)
	    delay 1000
	    emitlocalstream measurement      : measurement(31)
	    delay 1000
	    
	    // di nuovo presente per 2 secondi, assente per 3
	    emitlocalstream measurement      : measurement(10)
	    delay 1000
	    emitlocalstream measurement      : measurement(10)
	    delay 1000
	    emitlocalstream measurement      : measurement(20)
	    delay 1000
	    emitlocalstream measurement      : measurement(20)
	    delay 1000
	    emitlocalstream measurement      : measurement(20)
	    delay 1000
	   
	}
	
	State work2{
		[#
			while(true) {
				// 1/12 di probabilitÃ  di un guasto 
				if ((0..11).random() == 0) {
		 #]
		 			emitlocalstream measurement : measurement(100)
		    		delay 1000
		    		emitlocalstream measurement : measurement(100)
		    		delay 1000
		    		emitlocalstream measurement : measurement(100)
		    		delay 5000 // guasto per 5 secondi
		 [#
		    	}
		    	else {
		#]
					emitlocalstream measurement : measurement(10)
		    		delay 1000
		[#	
				}
			}
		#]
	}
}


QActor measuresprocessor context ctx_sensor {
	
	[#
		val DFREE = 30
		var guasto = false
		var counterError = 0
		var counterDeposit = 0
		var doDepositSent = false
		var deposit = false
	#]
	
	State s0 initial{
		delay 3000
		println("$name : starting") color cyan 
//		// CODE NEEDED TO LOAD MONGODB AT THE FIRST BOOT OF THE SYSTEM 
//		println("$name : loading productservice db") color cyan 
//		[# 
//			val JsonObj1 = "'{\"productId\":1,\"name\":\"p1\",\"weight\":10}'" 
//			val JsonObj2 = "'{\"productId\":2,\"name\":\"p2\",\"weight\":20}'" 
//			val JsonObj3 = "'{\"productId\":3,\"name\":\"p3\",\"weight\":30}'" 
//			val JsonObj4 = "'{\"productId\":4,\"name\":\"p4\",\"weight\":40}'" 
//			val JsonObj5 = "'{\"productId\":5,\"name\":\"p5\",\"weight\":200}'" 
//		#]
//		request productservice -m createProduct : product($JsonObj1)
//		request productservice -m createProduct : product($JsonObj2)
//		request productservice -m createProduct : product($JsonObj3)
//		request productservice -m createProduct : product($JsonObj4)
//		request productservice -m createProduct : product($JsonObj5)

	 	subscribeTo sonarsimulator  for measurement
	} 
	Goto listen_for_measurement
	
	
	State listen_for_measurement {
		//aspetto
	}
	Transition t
		whenEvent measurement -> process
		whenEvent waitingForDeposit -> checkForDeposit
		whenEvent stopWaitingForDeposit -> stopWaitingDeposit
		
	State process{
		[# var M = -1 #]
		onMsg(measurement : measurement(X)){
			[#
				M = payloadArg(0).toInt()
			#]
		}
		
		if[# M < DFREE/2 #]{
			println("$name container presente") color cyan
			[#
				counterError = 0
				counterDeposit += 1
			#]
			
			if[# deposit && counterDeposit >= 3 && !doDepositSent #]{
				println("$name invio deposito") color green
				emit doDeposit : doDeposit(1)
				[# doDepositSent = true #]
			}
		}
		
		if[# M >= DFREE/2 && M <= DFREE #]{
			println("$name container assente") color cyan
			[#
				counterError = 0
				counterDeposit = 0
				doDepositSent = false
			#]
		}
		
		if[# M > DFREE #]{
			println("$name possibile guasto") color red
			[#
				counterError += 1
				counterDeposit = 0
				doDepositSent = false
			#]
		}
		
		if[# counterError >= 3 && !guasto #]{
			println("$name GUASTO") color red
			[# 
				guasto = true 
			#]
			emit sonaralert : sonaralert(1)
		} else {
			if [# guasto && counterError < 3 #] {
				println("$name GUASTO RIENTRATO") color yellow
				[# guasto = false #]
				emit sonarok : sonarok(1)
			}
		}
	}
	Goto listen_for_measurement
	
	State checkForDeposit{
		[#deposit = true #]
		println("$name checking for deposit") color cyan
		
		if[# counterDeposit >= 3 #]{
			println("$name invio deposito") color green
			[# doDepositSent = true #]
			emit doDeposit : doDeposit(1)
			
		} 
		else {
			println("$name deposit NOT confirmed: needing other measurements") color cyan
		}
	}
	Goto listen_for_measurement
	
	State stopWaitingDeposit{
		[# deposit = false#]
	}
	Goto listen_for_measurement
}

QActor led context ctx_sensor{
	State s0 initial{
		println("$name starting") color cyan
 	}
 	Goto wait
 	
 	State wait{
 		println("$name waiting for interrupts") color cyan
 	}
 	
 	Transition t
 		whenEvent sonaralert -> acceso
 		whenEvent sonarok -> spento
 		
 	State acceso{
 		println("$name acceso") color red
 	}
 	Goto wait
 	
 	State spento{
 		println("$name spento") color green
 	}
 	Goto wait
}