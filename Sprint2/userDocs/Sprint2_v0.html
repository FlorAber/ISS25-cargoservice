<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="it">
  <head>
    <!-- <script type="text/javascript" src="../css/issStyle.js"></script> -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"
      crossorigin="anonymous"
    ></script>
    <!-- <link rel="stylesheet" type="text/css" href="../../resources/_styles/style.css" /> -->
    <link rel="stylesheet" type="text/css" href="./css/style.css" />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <title>ISS25 - Sprint 2</title>
  </head>

  <body>
    <div id="top">
      <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE - Sprint 2</h1>
    </div>
    <div class="body">
      <h2>Introduction</h2>
      <div class="remark">
        <div class="textbody grid-x grid-margin-x align-middle">
          <div class="medium-8">
            Nello Sprint precedente sono state analizzate le problematiche ed è stato progettato il Core Business del del sistema cargoservice. 
            L'output finale è stato una modellazione di alto livello del sistema e una prima implementazione funzionante (figura a destra).
            <br />
            <br />
            L'obiettivo dello Sprint 2 è di analizzare le problematiche relative 
            al componente Sensor e realizzarne un'implementazione funzionante, integrandola con il corebusiness del sistema.
            D'ora in avanti ci riferiremo al corebusiness del sistema chiamandolo
            semplicemente <strong>cargoservice</strong>.
          </div>
          <div class="medium-4">
            <img
              src="../../Sprint1/sprint1_system_overviewarch.png"
              alt="Sprint 1 System Overview"
              width="100%"
            />
          </div>
        </div>
        
    </div>

    <h2>Requirements</h2>
    <div class="remark">
      I requisiti che intendiamo soddisfare in questo sprint sono i
      seguenti:
      <ul>
        <li>
          Il sensore, posto di fronte alla IOPort è un sonar utilizzato per rilevare la presenza di un product container, quando misura una distanza D tale che D < DFREE/2 per un tempo ragionevole (es. 3 secondi) 
        </li>
        <li>
          Quando il sonar misura una distanza D > DFREE per almeno 3 secondi il sistema interrompe le prorpie attività e si accende un led. Il servizio riparte appena il sonar misura una distanza D <= DREE
        </li>
      </ul>
    </div>

    <h2>Problem analysis</h2>
    <div class="remark">
      <div class="textparagraph">
        <h3>Come modellare Sensor e i suoi componenti?</h3>
          <div class="textbody">
            Dall'analisi dei requisiti emerge la necessità di gestire almeno due componenti hardware: un sonar per il rilevamento dei prodotti e un led per la segnalazione fisica dei malfunzionamenti.
            Per l'implementazione del sistema, vista la natura dei componenti da gestire, verrà utilizzata una scheda RaspberryPi.

            <br/>
            Le possibili soluzioni di modellazione del contesto sensor e dei suoi componenti sono:
            <ul>
              <li>Modellare sensor come un unico componente che si occupa di gestire sia il <strong>sonar</strong> che il <strong>led</strong> modellati come POJO</li>
              <li>Modellare sensor come un contesto che a sua volta contiene due attori, uno <strong>sonar</strong> e uno <strong>led</strong></li>
            </ul>
            Si suggerisce la seconda opzione in quanto consente di separare le responsabilità dei due componenti hardware e permette a led e sonar di intercettare e gestire in modo autonomo le comunicazioni con <strong>cargoservice</strong>.
          </div>
      </div>
      <div class="textparagraph">
        <h3>Sonar</h3>
        <div class="textbody">Parlando in dettaglio del componente sonar sorge spontaneo domandarsi se:
          <ul>
            <li>sia opportuno fare in modo che il sonar comunichi direttamente con il cargoservice ogni 
              volta che si verifica un evento di interesse (rilevamento prodotto o malfunzionamento)
            </li>
            <li>
              sia meglio che il sonar comunichi con cargoservice ogni distanza rilevata
            </li>
          </ul>
          Siccome il sistema cargoservice è stato modellato per reagire ad eventi specifici
          piuttosto che a flussi continui di dati, è preferibile che il sonar comunichi con cargoservice
          solo quando rileva un evento di interesse. Inoltre le comunicazioni dal sonar a cargoservice
          dipendono dagli eventi già modellati nel sistema cargoservice, nello specifico:
          <ul>
            <li>l'evento <i>waitingForDeposit</i> segnala che una richiesta di caricamento è stata accettata da cargoservice e il sonar 
              avvia la rilevazione dei prodotti </li>
            <li>l'evento <i>stopWaitingForDeposit</i> segnala al sonar che il caricamento è terminato e non c'è nessuna
              richiesta di caricamento in sospeso, arrestando la rilevazione</li>
          </ul> 
          <br/>

          inoltre all'interno del sistema precedentemente modellato sono già stati definiti gli eventi che il sonar può sfruttare per interagire con <strong>cargoservice</strong>:
          <ul>
            <li>il sonar ha rilevato un prodotto (D < DFREE/2 per minimo 3 secondi); scatena l'evento <i>doDeposit</i></li>
            <li>il sonar rileva un malfunzionamento (D > DFREE per minimo 3 secondi); scatena l'evento <i>sonaralert</i></li>
            <li>il sonar esce dallo stato di malfunzionamento (almeno una misurazione D < DFREE); scatena l'evento <i>sonarok</i></li>
          </ul>

          <h4> Come sfruttare il sonar fisico? </h4>
          Occorre domandarsi come il componente software sonar possa relazionarsi con il componente hardware sonar.
          Fortunatamente il committente ha precedentemente fornito uno script Python che permette di interfacciarsi con l'hardware 
          del RaspberryPi sfruttando la libreria GPIO e si occupa di recuperare le distanze lette dal sonar, 
          ottenendo una misurazione della distanza <strong>D</strong> a intervalli della durata di un secondo.

          <pre><code># File: sonar.py
import RPi.GPIO as GPIO
import time
import sys

GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
TRIG = 17
ECHO = 27

GPIO.setup(TRIG, GPIO.OUT)
GPIO.setup(ECHO, GPIO.IN)
GPIO.output(TRIG, False)   # TRIG parte LOW

print ('Waiting a few seconds for the sensor to settle')
time.sleep(2)

while True:
  GPIO.output(TRIG, True)    #invia impulso TRIG
  time.sleep(0.00001)
  GPIO.output(TRIG, False)

  pulse_start = time.time()
  #attendi che ECHO parta e memorizza tempo
  while GPIO.input(ECHO)==0:
      pulse_start = time.time()
  # register the last timestamp at which the receiver detects the signal.
  while GPIO.input(ECHO)==1:
      pulse_end = time.time()
  pulse_duration = pulse_end - pulse_start

  # velocità del suono ~= 340m/s 
  # distanza = v*t 
  # il tempo ottenuto misura un roundtrip -> distanza = v*t/2
  distance = pulse_duration * 17165
  distance = round(distance, 1)
  print ('Distance:', distance,'cm')
  sys.stdout.flush()
  time.sleep(1)</code></pre>
        </div>
      </div>

      <div class="textparagraph">
        <h3>Led</h3>
        <div class="textbody">Il led come da requisiti ha il compito di accendersi e spegnersi 
          in base allo stato di funzionamento del sonar.
          La rilevazione dello stato del sonar può avvenire in tre modi:
          <ul>  
            <li>Il led intercetta gli eventi di interesse inviati dal sonar a cargoservice e si accende/spegne di conseguenza</li>
            <li>Il cargoservice invia un messaggio al led per accendersi/spegnersi in base allo stato del sonar</li>
            <li>Il sonar comunica con messaggi diretti al led i propri cambi di stato</li>
          </ul>
          Si suggerisce la prima opzione in quanto consente di modellare il led come un componente autonomo che non necessita di comunicazione diretta con gli altri componenti del sistema, inoltre sfruttare 
          eventi già presenti nel sistema permette di ridurre il traffico di rete generato.

          <h4> Come sfruttare il led fisico? </h4>
          Per quanto riguarda l'interfacciamento con l'hardware, anche in questo caso
          il committente ha fornito degli utili script Python, uno per l'accensione:
          <pre><code>#file ledPython25On.py
import RPi.GPIO as GPIO 
import time

'''
----------------------------------
CONFIGURATION

'''
GPIO.setmode(GPIO.BCM)
GPIO.setup(25,GPIO.OUT)

'''
----------------------------------
main activity
----------------------------------
'''
GPIO.output(25,GPIO.HIGH)
</code></pre>
        E uno per lo spegnimento:
<pre><code>#file ledPython25Off.py
# -------------------------------------------------------------
#
# -------------------------------------------------------------
import RPi.GPIO as GPIO 
import time

'''
----------------------------------
CONFIGURATION
----------------------------------
'''
GPIO.setmode(GPIO.BCM)
GPIO.setup(25,GPIO.OUT)

'''
----------------------------------
main activity
----------------------------------
'''

GPIO.output(25,GPIO.LOW)</code></pre>
        </div>
      </div>
    </div>

    <h2>Logical Architecture</h2>
    <div class="medium-12 text-center remark">
      <img
        src="./resources/sprint2_logicalArch.png"
        class="text-center"
        alt="map"
        width="75%"
      />
    </div>

    <h2>Test plans</h2>
    <div class="remark">
      <div class="textbody">
        Lo scopo della fase di test è quello di verificare il corretto funzionamento del
        sistema modellato, cioè del contesto <strong>sensor</strong>.

        <div class="textbody">
          <table class="test-plan-table">
            <thead>
              <tr>
                <th>Test</th>
                <th>Attori</th>
                <th>Descrizione</th>
                <th>Modello</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Verifica errore</td>
                <td>led; sonar;</td>
                <td>
                    Il sonar riceve per 3 secondi misurazioni maggiori di DFREE, il sistema va in errore e il led si accende. 
                    Alla ricezione della prima misurazione minore di DFREE il sistema rientra dal guasto e il led si spegne.
                </td>
                <td><a href="../src/test/java/TestSonarSystem.java">TestSonarSystem.java</a></td>
              </tr>
              <tr>
                <td>Verifica invio doDeposit</td>
                <td>led; sonar;</td>
                <td>
                    Led inizialmente spento, il sonar per 3 secondi riceve misurazioni maggiori di DFREE/2 e minori di DFREE. Il sistema emette l'evento doDeposit.
                </td>
                <td><a href="../src/test/java/TestSonarSystem.java">TestSonarSystem.java</a></td>
              </tr>
                <td>Verifica nessun errore con 2 misurazioni</td>
                <td>led; sonar;</td>
                <td>
                    Il sonar riceve per 2 secondi misurazioni maggiori di DFREE, il sistema non va in guasto e il led rimane spento.
                </td>
                <td><a href="../src/test/java/TestSonarSystem.java">TestSonarSystem.java</a></td>
              </tr>
                <td>Verifica robustezza a cicli multipli</td>
                <td>led; sonar;</td>
                <td>
                    Si itera la sequenza guasto e rientro dal guasto più volte consecutivamente, andando a verificare che il led
                    si accenda e spenga correttamente.
                </td>
                <td><a href="../src/test/java/TestSonarSystem.java">TestSonarSystem.java</a></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <h2>Project</h2>
    <div class="remark">
      Per seguire il single responsibility principle è stato deciso di affidare
      a diversi attori la gestione delle distinte parti del sistema.

      <div class="textparagraph">
        <h3>Gestione del sonar</h3>
        <div class="textbody">
              Il componente software che modella il sonar di fatto dovrà risolvere
                  due problemi principali:
                  <ul>
                    <li>Interfacciarsi con lo script Python per ottenere le misurazioni della distanza dal sonar fisico;</li>
                    <li>Comunicare con cargoservice quando si verificano eventi di interesse.</li>
                  </ul>
            Per separare le funzionalità è stato deciso di modellare un componente chiamato <strong>sonarmanager</strong> per
            processare le misurazioni e comunicare con il cargoservice.
            Il componente <strong>sonar</strong> si occuperà invece di eseguire lo script Python e inviare le misurazioni a <strong>sonarmanager</strong>.
          
          <h4>comportamento di sonarmanager</h4>
          <strong>sonarmanager</strong> è incaricato di esaminare i messaggi ricevuti da <strong>sonar</strong> tramite la dispatch
          <i>measurement</i> e di scatenare i seguenti eventi in base alle misurazioni:
          <ul>
            <li>se D < DFREE/2 per 3 secondi, scatenerà l'evento <i>doDeposit</i>;</li>
            <li>se D > DFREE per 3 secondi, scatenerà l'evento <i>sonaralert</i>.</li>
            <li>se D < DFREE in seguito ad un malfunzionamento, scatenerà l'evento <i>sonarok</i>.</li>
          </ul>

          <pre><code>//Qactor sonarmanager :
State process{
	[# var M = -1 #]
	onMsg(measurement : measurement(X)){
		[#
			M = payloadArg(0).toInt()
		#]
	}
	
	if[# M < DFREE/2 #]{
		println("$name container presente") color cyan
		[#
			counterError = 0
			counterDeposit += 1
		#]
		
		if[# deposit && counterDeposit >= 3 && !doDepositSent #]{
			println("$name invio deposito") color green
			emit doDeposit : doDeposit(1)
			[# doDepositSent = true #]
		}
	}
	
	if[# M >= DFREE/2 && M <= DFREE #]{
		println("$name container assente") color cyan
		[#
			counterError = 0
			counterDeposit = 0
			doDepositSent = false
		#]
	}
	
	if[# M > DFREE #]{
		println("$name possibile guasto") color red
		[#
			counterError += 1
			counterDeposit = 0
			doDepositSent = false
		#]
	}
	
	if[# counterError >= 3 && !guasto #]{
		println("$name GUASTO") color red
		[# 
			guasto = true 
		#]
		emit sonaralert : sonaralert(1)
	} else {
		if [# guasto && counterError < 3 #] {
			println("$name GUASTO RIENTRATO") color yellow
			[# guasto = false #]
			emit sonarok : sonarok(1)
		}
	}
}
Goto listen_for_measurement
State listen_for_measurement {
	//waiting
}
Transition t
	whenMsg measurement -> process
	whenEvent waitingForDeposit -> checkForDeposit
	whenEvent stopWaitingForDeposit -> stopWaitingDeposit
</code></pre>

          <h4>comportamento di sonar</h4>
          <strong>sonar</strong> si occupa di eseguire lo script Python per ottenere le misurazioni
          della distanza dal sonar fisico in cm e inviarle a sonarmanager.
          <pre><code>QActor sonar context ctx_sensor{
	[#
	lateinit var reader : java.io.BufferedReader
    lateinit var p : Process	
    var D= 0
	#
	]
	State s0 initial{
		delay 2000
		println("$name: starting") color cyan
		[#
		p       = Runtime.getRuntime().exec("python sonar.py")
		reader  = java.io.BufferedReader( java.io.InputStreamReader(p.getInputStream()) )
		#
		]
	}
	Goto work
	
	State work{
		delay 1000
		[#
		
		var data = reader.readLine()
			
			if( data != null ){
				try{ 
					val v = data.toInt()
					D = v
				}catch(e: Exception){
					CommUtils.outred("$name ERROR FROM READING SONAR DATA: $e")
				}
			}
		
		#
		]
		forward sonarmanager -m measurement : measurement($D)
	    delay 1000
	   
	}
	Goto work
	
}</code></pre>
          <h4>comportamento di led</h4>

          <strong>led</strong> si occupa di eseguire gli script Python per accendere e spegnere il led
          basandosi sugli eventi scatenati da <strong>sonarmanager</strong>.
          nello specifico:
          <ul>
            <li>all'evento <i>sonaralert</i> esegue lo script ledPython25On.py;</li>
            <li>all'evento <i>sonarok</i> esegue lo script ledPython25Off.py.</li>
          </ul>

          <pre><code>QActor led context ctx_sensor{
	[#
    lateinit var p : Process	
		#
	]
	State s0 initial{
		println("$name starting") color cyan
 	}
 	Goto wait
 	
 	State wait{
 		println("$name waiting for interrupts") color cyan
 	}
 	
 	Transition t
 		whenEvent sonaralert -> acceso
 		whenEvent sonarok -> spento
 		
 	State acceso{
 		println("$name acceso") color red
 		[#
 			p       = Runtime.getRuntime().exec("python ledPython25On.py")	
 		#
 		]
 		
 	}
 	Goto wait
 	
 	State spento{
 		println("$name spento") color green
 		[#
 			p       = Runtime.getRuntime().exec("python ledPython25Off.py")	
 		#
 		]
 	}
 	Goto wait
}</code></pre>
        </div>
      </div>
    </div>
    <h2>System Design</h2>

      <div class="medium-12 text-center remark">
        <img
          src="../sprint2_sensors_modelarch.png"
          class="text-center"
          alt="map"
          width="75%"
        />

      </div>


      <h2>Considerazioni finali e Deployment</h2>
      <div class="remark">
        Per l'esecuzione del sistema è necessario avviare preliminarmente i servizi
        definiti nel file: <code>yamls/docker-compose-unified.yaml</code>.<br/>
        Il sistema, ad esclusione della GUI prevista per il prossimo Sprint, è operativo
        ed è composto da due moduli principali:
        <ol>
          <li> Il core business è stato implementato nel progetto gradle contenuto all'interno della directory <code>Sprint1</code> e può essere eseguito lanciando il comando <code>gradle run</code> all'interno della directory</li>
          <li> Il componente sensors è stato implementato nel progetto gradle contenuto all'interno della directory <code>Sprint2</code> e può essere lanciato caricando sul RaspberryPi il contenuto della directory <code>Sprint2/build/libs/</code> ed eseguendo l'archivio <code>sprint2_sensors_model-1.0.jar</code> tramite il comando: <code>java -jar sprint2_sensors_model-1.0.jar</code>
            <br/>
            Per il corretto funzionamento del modulo dedicato alla gestione dei sensori è necessario collegare i dispositivi ai seguenti pin della scheda:
            <ul>
              <li>LED (polo positivo): <strong>pin 25</strong></li>
              <li>Sonar – trigger: <strong>pin 17</strong></li>
              <li>Sonar – echo: <strong>pin 27</strong></li>
              <li>
                Gli altri collegamenti possono essere effettuati liberamente, in particolare: l'alimentazione del sonar può essere collegata ad un qualsiasi pin di alimentazione a 5V; i collegamenti a terra di sonar e led possono essere fatti su un qualsiasi pin Ground
              </li>
            </ul>
          </li>
        </ol>
      </div>

      <footer class="footer">
        <div class="grid-container fluid">
          <div class="grid-x grid-margin-x align-middle">
            <div class="small-12 medium-3 text-center">
              <a
                class="button change"
                href="../../Sprint1/userDocs/sprint1_v3.html"
              >
                &larr; Previous Sprint
              </a>
            </div>

            <div class="small-12 medium-4 text-center">
              Fasano Andrea : andrea.fasano3@studio.unibo.it <br />
              <!-- 0001189592 -->
              Florian Alberto : alberto.florian@studio.unibo.it <br />
              <!-- 0001189572 -->
              Sampaoli Giacomo : giacomo.sampaoli@studio.unibo.it
              <!-- 0001176431 -->
            </div>

            <div class="small-12 medium-2 align-middle text-center">
              <a
                href="https://github.com/FlorAber/ISS25-cargoservice"
                class="button primary"
                target="_blank"
              >
                GitHub Repository
              </a>
            </div>

            <div class="small-12 medium-3 text-right">
              <a class="button change disabled"> Next Sprint &rarr; </a>
            </div>
          </div>
        </div>
      </footer>

</body> 
