<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="it">
  <head>
    <!-- <script type="text/javascript" src="../css/issStyle.js"></script> -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"
      crossorigin="anonymous"
    ></script>
    <!-- <link rel="stylesheet" type="text/css" href="../../resources/_styles/style.css" /> -->
    <link rel="stylesheet" type="text/css" href="./css/style.css" />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <title>ISS25 - Sprint 2</title>
  </head>

  <body>
    <div id="top">
      <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE - Sprint 2</h1>
    </div>
    <div class="body">
      <h2>Introduction</h2>
      <div class="remark">
        <div class="textbody grid-x grid-margin-x align-middle">
          <div class="medium-8">
            Nello Sprint precedente sono state analizzate le problematiche e progettato il sistema relativo al Core Business
            del sistema cargoservice. L'output finale è stato una modellazione di alto livello del sistema e una
            prima implementazione funzionante del core business (figura a destra).
             <br />
            <br />
            L'obiettivo dello Sprint 2 è di analizzare le problematiche relative 
            al componente Sensor, sorte in fase di analisi dei requisiti
            e realizzarne
            un'implementazione funzionante integrandola con il corebusiness del sistema cargoservice, 
            da fornire al committente.
            D'ora in avanti ci riferiremo al corebusiness del sistema chiamandolo
            semplicemente <strong>cargoservice</strong>.
          </div>
          <div class="medium-4">
            <img
              src="../../Sprint1/sprint1_system_overviewarch.png"
              alt="Sprint 1 System Overview"
              width="100%"
            />
          </div>
        </div>
        
    </div>
    <h2>Requirements</h2>

      <div class="remark">
        I requisiti che intendiamo soddisfare in questo sprint sono i
        seguenti:
        <ul>
                    <li>
            The sensor put in front of the IOPort is a sonar used
             to detect the presence of a product container, when it
              measures a distance D, such that D < DFREE/2,
               during a reasonable time (e.g. 3 secs).
          </li>
          <li>
            interrupts any activity and turns on a led if
             the sonar sensor measures a distance D > DFREE for at least 3 secs
              (perhaps a sonar failure). The service continues its activities as
               soon as the sonar measures a distance D <= DFREE.
          </li>

        </ul>
        

      </div>
      <h2>Problem analysis</h2>

      <div class="remark">
        <div class="textparagraph">
          <h3>Come modellare Sensor e i suoi componenti?</h3>
            <div class="textbody">Dall'analisi dei requisiti emerge la necessità di gestire 
            almeno due componenti hardware: un sonar per il rilevamento dei prodotti e un led per la segnalazione di malfunzionamenti.
            Per l'implementazione del sistema data la natura dei componenti
            da gestire verrà utilizzata una scheda Raspberry Pi.

            <br/>
            Le possibilità per modellare il contesto sensor e i suoi componenti
            può ricadere su due soluzioni principali:
            <ul>
              <li>Modellare sensor come un unico componente che si occupa di gestire sia il <strong>sonar</strong> che il <strong>led</strong> modellati come POJO;</li>
              <li>Modellare sensor come un contesto che a sua volta contiene due attori, uno <strong>sonar</strong> e uno <strong>led</strong>.</li>
            </ul>
            Si suggerisce la seconda opzione in quanto consente di separare le responsabilità dei due componenti hardware
            e permette a led e sonar di intercettare e gestire in modo autonomo le comunicazioni con <strong>cargoservice</strong>.
                
            </div>
        </div>
        <div class="textparagraph">
          <h3>Sonar</h3>
          <div class="textbody">Parlando in dettaglio del componente sonar sorge spontaneo domandarsi se:
            <ul>
              <li>sia opportuno fare in modo che il sonar comunichi direttamente con il cargoservice ogni 
                volta che rileva un evento di interesse (rilevamento prodotto o malfunzionamento);
              </li>
              <li>
                sia meglio che il sonar comunichi con cargoservice ogni distanza rilevata;
              </li>
            </ul>
            Siccome il sistema cargoservice è stato modellato per reagire ad eventi specifici
            piuttosto che a flussi continui di dati, è preferibile che il sonar comunichi con cargoservice
            solo quando rileva un evento di interesse. Inoltre le comunicazioni dal sonar a cargoservice
            dipendono dagli eventi già modellati nel sistema cargoservice, nello specifico:
            <ul>
              <li>l'evento <i>waitingForDeposit</i> segnala che la richiesta di caricamento è stata accettata da cargoservice e il sonar 
                avvia la rilevazione dei prodotti;</li>
              <li>l'evento <i>stopWaitingForDeposit</i> segnala al sonar che il caricamento è terminato e non c'è nessuna
                richiesta di caricamento in sospeso, arrestando la rilevazione;</li>
            </ul> 
            <br/>
            è possibile individuare già ora almeno altre 2 interazioni principali con <strong>cargoservice</strong>:
            <ul>
              <li>il sonar ha rilevato un prodotto (D < DFREE/2 per minimo 3 secondi) e comunica l'evento <i>doDeposit</i> a cargoservice;</li>
              <li>il sonar rileva un malfunzionamento (D > DFREE per minimo 3 secondi) e comunica l'evento <i>sonaralert</i> a cargoservice.</li>
            </ul>

            Sorge spontaneo domandarsi come il componente software sonar possa relazionarsi con il componente hardware sonar.
            Fortunatamente il committente ha precedentemente fornito uno script Python che si occupa di interfacciarsi con l'hardware 
            Raspberrypi mediante la libreria GPIO e restituire la distanza rilevata, 
            ottenendo una misurazione al secondo della distanza <strong>D</strong>.

            <pre>
              <code># File: sonar.py
import RPi.GPIO as GPIO
import time
import sys

GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
TRIG = 17
ECHO = 27

GPIO.setup(TRIG, GPIO.OUT)
GPIO.setup(ECHO, GPIO.IN)
GPIO.output(TRIG, False)   # TRIG parte LOW

print ('Waiting a few seconds for the sensor to settle')
time.sleep(2)

while True:
    GPIO.output(TRIG, True)    #invia impulso TRIG
    time.sleep(0.00001)
    GPIO.output(TRIG, False)

    pulse_start = time.time()
    #attendi che ECHO parta e memorizza tempo
    while GPIO.input(ECHO)==0:
        pulse_start = time.time()
    # register the last timestamp at which the receiver detects the signal.
    while GPIO.input(ECHO)==1:
        pulse_end = time.time()
    pulse_duration = pulse_end - pulse_start

    # velocità del suono ~= 340m/s 
    # distanza = v*t 
    # il tempo ottenuto misura un roundtrip -> distanza = v*t/2
    distance = pulse_duration * 17165
    distance = round(distance, 1)
    print ('Distance:', distance,'cm')
    sys.stdout.flush()
    time.sleep(1)

              </code>
            </pre>

            
              
        </div>
        </div>

        <div class="textparagraph">
          <h3>Led</h3>
          <div class="textbody">Il led come da requisiti ha il compito di accendersi e spegnersi 
            in base allo stato di funzionamento del sonar.
            Questa interazione puo avvenire in tre modi:
            <ul>  
              <li>Il led intercetta gli eventi di interesse inviati dal sonar a cargoservice e si accende/spegne di conseguenza;</li>
              <li>Il cargoservice invia un messaggio al led per accendersi/spegnersi in base allo stato del sonar.</li>
              <li>Il sonar comunica con messaggi diretti al led i propri cambi di stato.</li>
            </ul>
            Si suggerisce la prima opzione in quanto consente di mantenere il led
            come un componente autonomo che non necessita di comunicare direttamente con gli altri componenti del sistema.


            Per quanto riguarda l'interfacciamento con l'hardware, anche in questo caso
            il committente ha fornito due script Python, uno per l'accensione:
            <pre>
              <code>
#file ledPython25On.py
# -------------------------------------------------------------
#
# -------------------------------------------------------------
import RPi.GPIO as GPIO 
import time

'''
----------------------------------
CONFIGURATION
----------------------------------
'''
GPIO.setmode(GPIO.BCM)
GPIO.setup(25,GPIO.OUT)

'''
----------------------------------
main activity
----------------------------------
'''
GPIO.output(25,GPIO.HIGH)
              </code>
            </pre>
            E uno per lo spegnimento:
            <pre>
              <code>
#file ledPython25Off.py
# -------------------------------------------------------------
#
# -------------------------------------------------------------
import RPi.GPIO as GPIO 
import time

'''
----------------------------------
CONFIGURATION
----------------------------------
'''
GPIO.setmode(GPIO.BCM)
GPIO.setup(25,GPIO.OUT)

'''
----------------------------------
main activity
----------------------------------
'''

GPIO.output(25,GPIO.LOW)

              </code>
            </pre>
          </div>
        </div>
        
        
        
    </div>
    <h2>Logical Architecture</h2>

      <div class="medium-12 text-center remark">
        <img
          src="./resources/sprint2_logicalArch.png"
          class="text-center"
          alt="map"
          width="75%"
        />

      </div>

      <h2>Test plans</h2>
    <div class="remark">
      <div class="textbody">
        Lo scopo della fase di test è quello di verificare il corretto funzionamento del
        sistema modellato, cioè del contesto <strong>sensor</strong>.

        <div class="textbody">
          <table class="test-plan-table">
            <thead>
              <tr>
                <th>Test</th>
                <th>Attori</th>
                <th>Descrizione</th>
                <th>Modello</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Verifica errore</td>
                <td>led; sonar;</td>
                <td>
                    Il sonar riceve per 3 secondi misurazioni maggiori di DFREE, il sistema va in errore e il led si accende. 
                    Alla ricezione della prima misurazione minore di DFREE il sistema rientra dal guasto e il led si spegne.
                </td>
                <td>TestSonarSystem.java</td>
              </tr>
              <tr>
                <td>Verifica invio doDeposit</td>
                <td>led; sonar;</td>
                <td>
                    Led inizialmente spento, il sonar per 3 secondi riceve misurazioni maggiori di DFREE/2 e minori di DFREE. Il sistema emette l'evento doDeposit.
                </td>
                <td>TestSonarSystem.java</td>
              </tr>
                <td>Verifica nessun errore con 2 misurazioni</td>
                <td>led; sonar;</td>
                <td>
                    Il sonar riceve per 2 secondi misurazioni maggiori di DFREE, il sistema non va in guasto e il led rimane spento.
                </td>
                <td>TestSonarSystem.java</td>
              </tr>
                <td>Verifica robustezza a cicli multipli</td>
                <td>led; sonar;</td>
                <td>
                    Si itera la sequenza guasto e rientro dal guasto più volte consecutivamente, andando a verificare che il led
                    si accenda e spenga correttamente.
                </td>
                <td>TestSonarSystem.java</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <h2>Project</h2>
    <div class="remark">
      Per seguire il single responsibility principle è stato deciso di affidare
      a diversi attori la gestione delle distinte parti del sistema.

      <div class="textparagraph">
        <h3>Il ciclo del componente software sonar </h3>
        <div class="textbody">

              Il componente software che modella il sonar di fatto dovrà risolvere
                  due problemi principali:
                  <ul>
                    <li>Interfacciarsi con lo script Python per ottenere le misurazioni della distanza dal sonar fisico;</li>
                    <li>Comunicare con cargoservice quando si verificano eventi di interesse.</li>
                  </ul>
            Per separare le funzionalità si suggerisce di modellare un componente chiamato <strong>sonarmanager</strong> per la
            realizzazione della fase di processing delle misurazioni e comunicazioni con cargoservice e un componente <strong>sonar</strong>
            che modella il comportamento del sonar fisico e invia le misurazioni a sonarmanager.
          
          <h4>comportamento di sonarmanager</h4>
          <strong>sonarmanager</strong> è incaricato di esaminare i messaggi ricevuti da sonar tramite dispatch
          <i>measurement</i> e di scatenare i seguenti eventi in base alle misurazioni
          registrate per 3 secondi di fila:
          <ul>
            <li>se D < DFREE/2 scatenerà l'evento <i>doDeposit</i>;</li>
            <li>se D > DFREE scatenerà l'evento <i>sonaralert</i>.</li>
            <li>se D < DFREE in seguito a un evento di tipo <i>sonaralert</i>,
              allora scatenerà l'evento <i>sonarok</i>.</li>
          </ul>

          <pre>
          <code>
            //Qactor sonarmanager :
State process{
	[# var M = -1 #]
	onMsg(measurement : measurement(X)){
		[#
			M = payloadArg(0).toInt()
		#]
	}
	
	if[# M < DFREE/2 #]{
		println("$name container presente") color cyan
		[#
			counterError = 0
			counterDeposit += 1
		#]
		
		if[# deposit && counterDeposit >= 3 && !doDepositSent #]{
			println("$name invio deposito") color green
			emit doDeposit : doDeposit(1)
			[# doDepositSent = true #]
		}
	}
	
	if[# M >= DFREE/2 && M <= DFREE #]{
		println("$name container assente") color cyan
		[#
			counterError = 0
			counterDeposit = 0
			doDepositSent = false
		#]
	}
	
	if[# M > DFREE #]{
		println("$name possibile guasto") color red
		[#
			counterError += 1
			counterDeposit = 0
			doDepositSent = false
		#]
	}
	
	if[# counterError >= 3 && !guasto #]{
		println("$name GUASTO") color red
		[# 
			guasto = true 
		#]
		emit sonaralert : sonaralert(1)
	} else {
		if [# guasto && counterError < 3 #] {
			println("$name GUASTO RIENTRATO") color yellow
			[# guasto = false #]
			emit sonarok : sonarok(1)
		}
	}
}
Goto listen_for_measurement
State listen_for_measurement {
	//waiting
}
Transition t
	whenMsg measurement -> process
	whenEvent waitingForDeposit -> checkForDeposit
	whenEvent stopWaitingForDeposit -> stopWaitingDeposit
	
            </code>
          </pre>
          <h4>comportamento di sonar</h4>
          <strong>sonar</strong> si occupa di eseguire lo script Python per ottenere le misurazioni
          della distanza dal sonar fisico in cm e inviarle a sonarmanager.
          <pre>
            <code>
QActor sonar context ctx_sensor{
	
	[#
	lateinit var reader : java.io.BufferedReader
    lateinit var p : Process	
    var D= 0
	#
	]
	State s0 initial{
		delay 2000
		println("$name: starting") color cyan
		[#
		p       = Runtime.getRuntime().exec("python sonar.py")
		reader  = java.io.BufferedReader( java.io.InputStreamReader(p.getInputStream()) )
		#
		]
	}
	Goto work
	
	State work{
		delay 1000
		[#
		
		var data = reader.readLine()
			
			if( data != null ){
				try{ 
					val v = data.toInt()
					D = v
				}catch(e: Exception){
					CommUtils.outred("$name ERROR FROM READING SONAR DATA: $e")
				}
			}
		
		#
		]
		forward sonarmanager -m measurement : measurement($D)
	    delay 1000
	   
	}
	Goto work
	
}
            </code>
          </pre>
          <h4>comportamento di led</h4>

          <strong>led</strong> si occupa di eseguire gli script Python per accendere e spegnere il led
          basandosi sugli eventi che cattura.
          nello specifico:
          <ul>
            <li>all'evento <i>sonaralert</i> esegue lo script ledPython25On.py;</li>
            <li>all'evento <i>sonarok</i> esegue lo script ledPython25Off.py.</li>
          </ul>

          <pre>
            <code>QActor led context ctx_sensor{
	[#
    lateinit var p : Process	
		#
	]
	State s0 initial{
		println("$name starting") color cyan
 	}
 	Goto wait
 	
 	State wait{
 		println("$name waiting for interrupts") color cyan
 	}
 	
 	Transition t
 		whenEvent sonaralert -> acceso
 		whenEvent sonarok -> spento
 		
 	State acceso{
 		println("$name acceso") color red
 		[#
 			p       = Runtime.getRuntime().exec("python ledPython25On.py")	
 		#
 		]
 		
 	}
 	Goto wait
 	
 	State spento{
 		println("$name spento") color green
 		[#
 			p       = Runtime.getRuntime().exec("python ledPython25Off.py")	
 		#
 		]
 	}
 	Goto wait
}
            </code>
          </pre>
        </div>
      </div>
    </div>
    <h2>System Design</h2>

      <div class="medium-12 text-center remark">
        <img
          src="../sprint2_sensors_modelarch.png"
          class="text-center"
          alt="map"
          width="75%"
        />

      </div>
      <footer class="footer">
        <div class="grid-container fluid">
          <div class="grid-x grid-margin-x align-middle">
            <div class="small-12 medium-3 text-center">
              <a
                class="button change"
                href="../../Sprint0/userDocs/sprint0_v3.html"
              >
                &larr; Previous Sprint
              </a>
            </div>

            <div class="small-12 medium-4 text-center">
              Fasano Andrea : andrea.fasano3@studio.unibo.it <br />
              <!-- 0001189592 -->
              Florian Alberto : alberto.florian@studio.unibo.it <br />
              <!-- 0001189572 -->
              Sampaoli Giacomo : giacomo.sampaoli@studio.unibo.it
              <!-- 0001176431 -->
            </div>

            <div class="small-12 medium-2 align-middle text-center">
              <a
                href="https://github.com/FlorAber/ISS25-cargoservice"
                class="button primary"
                target="_blank"
              >
                GitHub Repository
              </a>
            </div>

            <div class="small-12 medium-3 text-right">
              <a class="button change disabled"> Next Sprint &rarr; </a>
            </div>
          </div>
        </div>
      </footer>

</body> 
